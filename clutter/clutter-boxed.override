%%
override clutter_geometry_new kwargs
static int
_wrap_clutter_geometry_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x", "y", "width", "height", NULL };
	ClutterGeometry geom = { 0, 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iiii:ClutterGeometry.__init__",
					 kwlist,
					 &(geom.x), &(geom.y),
					 &(geom.width), &(geom.height)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_GEOMETRY, &geom);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_GEOMETRY;
	
	return 0;
}
%%
override-slot ClutterGeometry.tp_as_sequence
static int
_wrap_clutter_geometry_length (PyGBoxed *self)
{
	return 4;
}
static PyObject *
_wrap_clutter_geometry_getitem(PyGBoxed *self, int pos)
{
	ClutterGeometry *geom;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	geom = pyg_boxed_get (self, ClutterGeometry);
	switch (pos) {
		case 0: return PyInt_FromLong (geom->x);
		case 1: return PyInt_FromLong (geom->y);
		case 2: return PyInt_FromLong (geom->width);
		case 3: return PyInt_FromLong (geom->height);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_geometry_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterGeometry *geom;
	gint val;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	geom = pyg_boxed_get (self, ClutterGeometry);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: geom->x      = val; break;
		case 1: geom->y      = val; break;
		case 2: geom->width  = val; break;
		case 3: geom->height = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_geometry_tp_as_sequence = {
	(inquiry) _wrap_clutter_geometry_length,
	(binaryfunc) 0,
	(intargfunc) 0,
	(intargfunc) _wrap_clutter_geometry_getitem,
	(intintargfunc) 0,
	(intobjargproc) _wrap_clutter_geometry_setitem,
	(intintobjargproc) 0
};
%%
override-attr ClutterGeometry.x
static int
_wrap_clutter_geometry__set_x (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterGeometry)->x = val;

	return 0;
}
%%
override-attr ClutterGeometry.y
static int
_wrap_clutter_geometry__set_y (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterGeometry)->y = val;

	return 0;
}
%%
override-attr ClutterGeometry.width
static int
_wrap_clutter_geometry__set_width (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
        	return -1;
	
	pyg_boxed_get(self, ClutterGeometry)->width = val;
	
	return 0;
}
%%
override-attr ClutterGeometry.height
static int
_wrap_clutter_geometry__set_height (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	pyg_boxed_get (self, ClutterGeometry)->height = val;

	return 0;
}
%%
override clutter_actor_box_new kwargs
static int
_wrap_clutter_actor_box_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x1", "y1", "x2", "y2", NULL };
	ClutterActorBox box = { 0, 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iiii:ClutterActorBox.__init__",
					 kwlist,
					 &(box.x1), &(box.y1),
					 &(box.x2), &(box.y2)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_ACTOR_BOX, &box);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_ACTOR_BOX;
	
	return 0;
}
%%
override-slot ClutterActorBox.tp_as_sequence
static int
_wrap_clutter_actor_box_length (PyGBoxed *self)
{
	return 4;
}
static PyObject *
_wrap_clutter_actor_box_getitem(PyGBoxed *self, int pos)
{
	ClutterActorBox *box;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	box = pyg_boxed_get (self, ClutterActorBox);
	switch (pos) {
		case 0: return PyInt_FromLong (box->x1);
		case 1: return PyInt_FromLong (box->y1);
		case 2: return PyInt_FromLong (box->x2);
		case 3: return PyInt_FromLong (box->y2);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_actor_box_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterActorBox *box;
	gint val;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	box = pyg_boxed_get (self, ClutterActorBox);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: box->x1 = val; break;
		case 1: box->y1 = val; break;
		case 2: box->x2 = val; break;
		case 3: box->y2 = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_actor_box_tp_as_sequence = {
	(inquiry) _wrap_clutter_actor_box_length,
	(binaryfunc) 0,
	(intargfunc) 0,
	(intargfunc) _wrap_clutter_actor_box_getitem,
	(intintargfunc) 0,
	(intobjargproc) _wrap_clutter_actor_box_setitem,
	(intintobjargproc) 0
};
%%
override-attr ClutterActorBox.x1
static int
_wrap_clutter_actor_box__set_x1 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterActorBox)->x1 = val;

	return 0;
}
%%
override-attr ClutterActorBox.y1
static int
_wrap_clutter_actor_box__set_y1 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterActorBox)->y1 = val;

	return 0;
}
%%
override-attr ClutterActorBox.x2
static int
_wrap_clutter_actor_box__set_x2 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
        	return -1;
	
	pyg_boxed_get(self, ClutterActorBox)->x2 = val;
	
	return 0;
}
%%
override-attr ClutterActorBox.y2
static int
_wrap_clutter_actor_box__set_y2 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	pyg_boxed_get (self, ClutterActorBox)->y2 = val;

	return 0;
}
%%
override clutter_color_new kwargs
static int
_wrap_clutter_color_new (PyGBoxed *self,
			 PyObject *args,
			 PyObject *kwargs)
{
	static char *kwlist[] = { "red", "green", "blue", "alpha", NULL };
	ClutterColor color = { 0, 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iiii:ClutterColor.__init__",
					 kwlist,
					 &(color.red),
					 &(color.green),
					 &(color.blue),
					 &(color.alpha)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_COLOR, &color);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_COLOR;
	
	return 0;
}
%%
override-slot ClutterColor.tp_as_sequence
static int
_wrap_clutter_color_length (PyGBoxed *self)
{
	return 4;
}
static PyObject *
_wrap_clutter_color_getitem (PyGBoxed *self, int pos)
{
	ClutterColor *color;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString (PyExc_IndexError, "index out of range");
		return NULL;
	}

	color = pyg_boxed_get (self, ClutterColor);
	switch (pos) {
		case 0: return PyInt_FromLong (color->red);
		case 1: return PyInt_FromLong (color->green);
		case 2: return PyInt_FromLong (color->blue);
		case 3: return PyInt_FromLong (color->alpha);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_color_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterColor *color;
	gint val;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString (PyExc_IndexError, "index out of range");
		return -1;
	}

	color = pyg_boxed_get (self, ClutterColor);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch (pos) {
		case 0: color->red   = val; break;
		case 1: color->green = val; break;
		case 2: color->blue  = val; break;
		case 3: color->alpha = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_color_tp_as_sequence = {
	(inquiry) _wrap_clutter_color_length,
	(binaryfunc) 0,
	(intargfunc) 0,
	(intargfunc) _wrap_clutter_color_getitem,
	(intintargfunc) 0,
	(intobjargproc) _wrap_clutter_color_setitem,
	(intintobjargproc) 0
};
%%
override-attr ClutterColor.red
static int
_wrap_clutter_color__set_red (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterColor)->red = val;

	return 0;
}
%%
override-attr ClutterColor.green
static int
_wrap_clutter_color__set_green (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterColor)->green = val;

	return 0;
}
%%
override-attr ClutterColor.blue
static int
_wrap_clutter_color__set_blue (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
        	return -1;
	
	pyg_boxed_get(self, ClutterColor)->blue = val;
	
	return 0;
}
%%
override-attr ClutterColor.alpha
static int
_wrap_clutter_color__set_alpha (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	pyg_boxed_get (self, ClutterColor)->alpha = val;

	return 0;
}

