%%
ignore
  clutter_knot_free
%%
override clutter_geometry_new kwargs
static int
_wrap_clutter_geometry_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x", "y", "width", "height", NULL };
	ClutterGeometry geom = { 0, 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iiii:ClutterGeometry.__init__",
					 kwlist,
					 &(geom.x), &(geom.y),
					 &(geom.width), &(geom.height)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_GEOMETRY, &geom);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_GEOMETRY;
	
	return 0;
}
%%
override-slot ClutterGeometry.tp_as_sequence
static int
_wrap_clutter_geometry_length (PyGBoxed *self)
{
	return 4;
}
static PyObject *
_wrap_clutter_geometry_getitem (PyGBoxed *self, Py_ssize_t pos)
{
	ClutterGeometry *geom;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	geom = pyg_boxed_get (self, ClutterGeometry);
	switch (pos) {
		case 0: return PyInt_FromLong (geom->x);
		case 1: return PyInt_FromLong (geom->y);
		case 2: return PyInt_FromLong (geom->width);
		case 3: return PyInt_FromLong (geom->height);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_geometry_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterGeometry *geom;
	gint val;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	geom = pyg_boxed_get (self, ClutterGeometry);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: geom->x      = val; break;
		case 1: geom->y      = val; break;
		case 2: geom->width  = val; break;
		case 3: geom->height = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_geometry_tp_as_sequence = {
	(lenfunc) _wrap_clutter_geometry_length,
	0,
	0,
	(ssizeargfunc) _wrap_clutter_geometry_getitem,
	0,
	(ssizeobjargproc) _wrap_clutter_geometry_setitem,
        0
};
%%
override-attr ClutterGeometry.x
static int
_wrap_clutter_geometry__set_x (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterGeometry)->x = val;

	return 0;
}
%%
override-attr ClutterGeometry.y
static int
_wrap_clutter_geometry__set_y (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterGeometry)->y = val;

	return 0;
}
%%
override-attr ClutterGeometry.width
static int
_wrap_clutter_geometry__set_width (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
        	return -1;
	
	pyg_boxed_get(self, ClutterGeometry)->width = val;
	
	return 0;
}
%%
override-attr ClutterGeometry.height
static int
_wrap_clutter_geometry__set_height (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	pyg_boxed_get (self, ClutterGeometry)->height = val;

	return 0;
}
%%
override clutter_actor_box_new kwargs
static int
_wrap_clutter_actor_box_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x1", "y1", "x2", "y2", NULL };
	ClutterActorBox box = { 0, 0, 0, 0 };
        double x1, y1, x2, y2;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|dddd:ClutterActorBox.__init__",
					 kwlist,
					 &x1, &y1,
					 &x2, &y2))
		return -1;

        box.x1 = CLUTTER_UNITS_FROM_FLOAT (x1);
        box.y1 = CLUTTER_UNITS_FROM_FLOAT (y1);
        box.x2 = CLUTTER_UNITS_FROM_FLOAT (x2);
        box.y2 = CLUTTER_UNITS_FROM_FLOAT (y2);

	self->boxed = g_boxed_copy (CLUTTER_TYPE_ACTOR_BOX, &box);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_ACTOR_BOX;
	
	return 0;
}
%%
override-slot ClutterActorBox.tp_as_sequence
static int
_wrap_clutter_actor_box_length (PyGBoxed *self)
{
	return 4;
}
static PyObject *
_wrap_clutter_actor_box_getitem(PyGBoxed *self, int pos)
{
	ClutterActorBox *box;
        ClutterUnit res;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	box = pyg_boxed_get (self, ClutterActorBox);
	switch (pos) {
		case 0: res = box->x1;
		case 1: res = box->y1;
		case 2: res = box->x2;
		case 3: res = box->y2;
		default:
			g_assert_not_reached();
			return NULL;
	}

        return PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (res));
}
static int
_wrap_clutter_actor_box_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterActorBox *box;
	double val;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

        if (!PyFloat_Check (value)) {
                PyErr_SetString (PyExc_TypeError, "value must be floating point");
                return -1;
        }

	box = pyg_boxed_get (self, ClutterActorBox);
	val = PyFloat_AsDouble (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: box->x1 = CLUTTER_UNITS_FROM_FLOAT (val); break;
		case 1: box->y1 = CLUTTER_UNITS_FROM_FLOAT (val); break;
		case 2: box->x2 = CLUTTER_UNITS_FROM_FLOAT (val); break;
		case 3: box->y2 = CLUTTER_UNITS_FROM_FLOAT (val); break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_actor_box_tp_as_sequence = {
	(lenfunc) _wrap_clutter_actor_box_length,
	0,
	0,
	(ssizeargfunc) _wrap_clutter_actor_box_getitem,
	0,
	(ssizeobjargproc) _wrap_clutter_actor_box_setitem,
	0
};
%%
override-attr ClutterActorBox.origin
static PyObject *
_wrap_clutter_actor_box__get_origin (PyGBoxed *self, void *closure)
{
        ClutterUnit val;
        double x1, y1;
        
        val = pyg_boxed_get (self, ClutterActorBox)->x1;
        x1  = CLUTTER_UNITS_TO_FLOAT (val);

        val = pyg_boxed_get (self, ClutterActorBox)->y1;
        y1  = CLUTTER_UNITS_TO_FLOAT (val);

        return Py_BuildValue ("(dd)", x1, y1);
}
%%
override-attr ClutterActorBox.size
static PyObject *
_wrap_clutter_actor_box__get_size (PyGBoxed *self, void *closure)
{
        ClutterActorBox *box = pyg_boxed_get (self, ClutterActorBox);
        double width, height;

        width  = CLUTTER_UNITS_TO_FLOAT (box->x2 - box->x1);
        height = CLUTTER_UNITS_TO_FLOAT (box->y2 - box->y1);

        return Py_BuildValue ("(dd)", width, height);
}
%%
override-attr ClutterActorBox.x1
static int
_wrap_clutter_actor_box__set_x1 (PyGBoxed *self, PyObject *value, void *closure)
{
	double val;

	val = PyFloat_AsDouble (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterActorBox)->x1 =
          CLUTTER_UNITS_FROM_FLOAT (val);

	return 0;
}
static PyObject *
_wrap_clutter_actor_box__get_x1 (PyGBoxed *self, void *closure)
{
	double x1 = pyg_boxed_get (self, ClutterActorBox)->x1;
	return PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (x1));
}
%%
override-attr ClutterActorBox.y1
static int
_wrap_clutter_actor_box__set_y1 (PyGBoxed *self, PyObject *value, void *closure)
{
	double val;

	val = PyFloat_AsDouble (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterActorBox)->y1 =
          CLUTTER_UNITS_FROM_FLOAT (val);

	return 0;
}
static PyObject *
_wrap_clutter_actor_box__get_y1 (PyGBoxed *self, void *closure)
{
	double y1 = pyg_boxed_get (self, ClutterActorBox)->y1;
	return PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (y1));
}
%%
override-attr ClutterActorBox.x2
static int
_wrap_clutter_actor_box__set_x2 (PyGBoxed *self, PyObject *value, void *closure)
{
	double val;

	val = PyFloat_AsDouble (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterActorBox)->x2 =
          CLUTTER_UNITS_FROM_FLOAT (val);

	return 0;
}
static PyObject *
_wrap_clutter_actor_box__get_x2 (PyGBoxed *self, void *closure)
{
	double x2 = pyg_boxed_get (self, ClutterActorBox)->x2;
	return PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (x2));
}
%%
override-attr ClutterActorBox.y2
static int
_wrap_clutter_actor_box__set_y2 (PyGBoxed *self, PyObject *value, void *closure)
{
	double val;

	val = PyFloat_AsDouble (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterActorBox)->y2 =
          CLUTTER_UNITS_FROM_FLOAT (val);

	return 0;
}
static PyObject *
_wrap_clutter_actor_box__get_y2 (PyGBoxed *self, void *closure)
{
	double y2 = pyg_boxed_get (self, ClutterActorBox)->y2;
	return PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (y2));
}
%%
override clutter_knot_new kwargs
static int
_wrap_clutter_knot_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x", "y", NULL };
	ClutterKnot knot = { 0, 0, };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|ii:ClutterKnot.__init__",
					 kwlist,
					 &(knot.x), &(knot.y)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_KNOT, &knot);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_KNOT;
	
	return 0;
}
%%
override-slot ClutterKnot.tp_as_sequence
static int
_wrap_clutter_knot_length (PyGBoxed *self)
{
	return 2;
}
static PyObject *
_wrap_clutter_knot_getitem(PyGBoxed *self, int pos)
{
	ClutterKnot *knot;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 2) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	knot = pyg_boxed_get (self, ClutterKnot);
	switch (pos) {
		case 0: return PyInt_FromLong (knot->x);
		case 1: return PyInt_FromLong (knot->y);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_knot_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterKnot *knot;
	gint val;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 2) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	knot = pyg_boxed_get (self, ClutterKnot);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: knot->x = val; break;
		case 1: knot->y = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_knot_tp_as_sequence = {
	(lenfunc) _wrap_clutter_knot_length,
	0,
	0,
	(ssizeargfunc) _wrap_clutter_knot_getitem,
	0,
	(ssizeobjargproc) _wrap_clutter_knot_setitem,
	0
};
%%
override-attr ClutterKnot.x
static int
_wrap_clutter_knot__set_x (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterKnot)->x = val;

	return 0;
}
%%
override-attr ClutterKnot.y
static int
_wrap_clutter_knot__set_y (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterKnot)->y = val;

	return 0;
}
%%
override clutter_vertex_new kwargs
static int
_wrap_clutter_vertex_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x", "y", "z", NULL };
	ClutterVertex vertex = { 0, 0, 0 };
        double x, y, z;

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|ddd:ClutterVertex.__init__",
					 kwlist,
					 &x, &y, &z))
		return -1;

        vertex.x = CLUTTER_UNITS_FROM_FLOAT (x);
        vertex.y = CLUTTER_UNITS_FROM_FLOAT (y);
        vertex.z = CLUTTER_UNITS_FROM_FLOAT (z);

	self->boxed = g_boxed_copy (CLUTTER_TYPE_VERTEX, &vertex);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_VERTEX;
	
	return 0;
}
%%
override-slot ClutterVertex.tp_as_sequence
static Py_ssize_t
_wrap_clutter_vertex_length (PyGBoxed *self)
{
	return 3;
}
static PyObject *
_wrap_clutter_vertex_getitem (PyGBoxed *self, Py_ssize_t pos)
{
	ClutterVertex *vertex;
        ClutterUnit res;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 3) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	vertex = pyg_boxed_get (self, ClutterVertex);
	switch (pos) {
		case 0: res = vertex->x;
		case 1: res = vertex->y;
		case 2: res = vertex->z;
		default:
			g_assert_not_reached();
			return NULL;
	}

        return PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (res));
}
static Py_ssize_t
_wrap_clutter_vertex_setitem (PyGBoxed *self, Py_ssize_t pos, PyObject *value)
{
	ClutterVertex *vertex;
	double val;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 3) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

        if (!PyFloat_Check (value)) {
                PyErr_SetString(PyExc_TypeError, "value must be a float");

                return -1;
        }

	vertex = pyg_boxed_get (self, ClutterVertex);
	val = PyFloat_AsDouble (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: vertex->x = CLUTTER_UNITS_FROM_FLOAT (val); break;
		case 1: vertex->y = CLUTTER_UNITS_FROM_FLOAT (val); break;
		case 2: vertex->z = CLUTTER_UNITS_FROM_FLOAT (val); break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_vertex_tp_as_sequence = {
	(lenfunc) _wrap_clutter_vertex_length,
	0,
	0,
	(ssizeargfunc) _wrap_clutter_vertex_getitem,
	0,
	(ssizeobjargproc) _wrap_clutter_vertex_setitem,
	0
};
%%
override-attr ClutterVertex.x
static int
_wrap_clutter_vertex__set_x (PyGBoxed *self, PyObject *value, void *closure)
{
	double val;

	val = PyFloat_AsDouble (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterVertex)->x =
          CLUTTER_UNITS_FROM_FLOAT (val);

	return 0;
}
static PyObject *
_wrap_clutter_vertex__get_x (PyGBoxed *self, void *closure)
{
	double x = pyg_boxed_get (self, ClutterVertex)->x;
	return PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (x));
}
%%
override-attr ClutterVertex.y
static int
_wrap_clutter_vertex__set_y (PyGBoxed *self, PyObject *value, void *closure)
{
	double val;

	val = PyFloat_AsDouble (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterVertex)->y =
          CLUTTER_UNITS_FROM_FLOAT (val);

	return 0;
}
static PyObject *
_wrap_clutter_vertex__get_y (PyGBoxed *self, void *closure)
{
	double y = pyg_boxed_get (self, ClutterVertex)->y;
	return PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (y));
}
%%
override-attr ClutterVertex.z
static int
_wrap_clutter_vertex__set_z (PyGBoxed *self, PyObject *value, void *closure)
{
	double val;

	val = PyFloat_AsDouble (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterVertex)->z =
          CLUTTER_UNITS_FROM_FLOAT (val);

	return 0;
}
static PyObject *
_wrap_clutter_vertex__get_z (PyGBoxed *self, void *closure)
{
	double z = pyg_boxed_get (self, ClutterVertex)->z;
	return PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (z));
}
