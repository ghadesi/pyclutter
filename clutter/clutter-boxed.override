%%
override clutter_geometry_new kwargs
static int
_wrap_clutter_geometry_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x", "y", "width", "height", NULL };
	ClutterGeometry geom = { 0, 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iiii:ClutterGeometry.__init__",
					 kwlist,
					 &(geom.x), &(geom.y),
					 &(geom.width), &(geom.height)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_GEOMETRY, &geom);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_GEOMETRY;
	
	return 0;
}
%%
override-slot ClutterGeometry.tp_as_sequence
static int
_wrap_clutter_geometry_length (PyGBoxed *self)
{
	return 4;
}
static PyObject *
_wrap_clutter_geometry_getitem (PyGBoxed *self, int pos)
{
	ClutterGeometry *geom;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	geom = pyg_boxed_get (self, ClutterGeometry);
	switch (pos) {
		case 0: return PyInt_FromLong (geom->x);
		case 1: return PyInt_FromLong (geom->y);
		case 2: return PyInt_FromLong (geom->width);
		case 3: return PyInt_FromLong (geom->height);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_geometry_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterGeometry *geom;
	gint val;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	geom = pyg_boxed_get (self, ClutterGeometry);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: geom->x      = val; break;
		case 1: geom->y      = val; break;
		case 2: geom->width  = val; break;
		case 3: geom->height = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_geometry_tp_as_sequence = {
	(inquiry) _wrap_clutter_geometry_length,
	(binaryfunc) 0,
	(intargfunc) 0,
	(intargfunc) _wrap_clutter_geometry_getitem,
	(intintargfunc) 0,
	(intobjargproc) _wrap_clutter_geometry_setitem,
	(intintobjargproc) 0
};
%%
override-attr ClutterGeometry.x
static int
_wrap_clutter_geometry__set_x (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterGeometry)->x = val;

	return 0;
}
%%
override-attr ClutterGeometry.y
static int
_wrap_clutter_geometry__set_y (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterGeometry)->y = val;

	return 0;
}
%%
override-attr ClutterGeometry.width
static int
_wrap_clutter_geometry__set_width (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
        	return -1;
	
	pyg_boxed_get(self, ClutterGeometry)->width = val;
	
	return 0;
}
%%
override-attr ClutterGeometry.height
static int
_wrap_clutter_geometry__set_height (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	pyg_boxed_get (self, ClutterGeometry)->height = val;

	return 0;
}
%%
override clutter_actor_box_new kwargs
static int
_wrap_clutter_actor_box_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x1", "y1", "x2", "y2", NULL };
	ClutterActorBox box = { 0, 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iiii:ClutterActorBox.__init__",
					 kwlist,
					 &(box.x1), &(box.y1),
					 &(box.x2), &(box.y2)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_ACTOR_BOX, &box);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_ACTOR_BOX;
	
	return 0;
}
%%
override-slot ClutterActorBox.tp_as_sequence
static int
_wrap_clutter_actor_box_length (PyGBoxed *self)
{
	return 4;
}
static PyObject *
_wrap_clutter_actor_box_getitem(PyGBoxed *self, int pos)
{
	ClutterActorBox *box;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	box = pyg_boxed_get (self, ClutterActorBox);
	switch (pos) {
		case 0: return PyInt_FromLong (box->x1);
		case 1: return PyInt_FromLong (box->y1);
		case 2: return PyInt_FromLong (box->x2);
		case 3: return PyInt_FromLong (box->y2);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_actor_box_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterActorBox *box;
	gint val;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	box = pyg_boxed_get (self, ClutterActorBox);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: box->x1 = val; break;
		case 1: box->y1 = val; break;
		case 2: box->x2 = val; break;
		case 3: box->y2 = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_actor_box_tp_as_sequence = {
	(inquiry) _wrap_clutter_actor_box_length,
	(binaryfunc) 0,
	(intargfunc) 0,
	(intargfunc) _wrap_clutter_actor_box_getitem,
	(intintargfunc) 0,
	(intobjargproc) _wrap_clutter_actor_box_setitem,
	(intintobjargproc) 0
};
%%
override-attr ClutterActorBox.x1
static int
_wrap_clutter_actor_box__set_x1 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterActorBox)->x1 = val;

	return 0;
}
%%
override-attr ClutterActorBox.y1
static int
_wrap_clutter_actor_box__set_y1 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterActorBox)->y1 = val;

	return 0;
}
%%
override-attr ClutterActorBox.x2
static int
_wrap_clutter_actor_box__set_x2 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
        	return -1;
	
	pyg_boxed_get(self, ClutterActorBox)->x2 = val;
	
	return 0;
}
%%
override-attr ClutterActorBox.y2
static int
_wrap_clutter_actor_box__set_y2 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	pyg_boxed_get (self, ClutterActorBox)->y2 = val;

	return 0;
}
%%
override clutter_knot_new kwargs
static int
_wrap_clutter_knot_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x", "y", NULL };
	ClutterKnot knot = { 0, 0, };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|ii:ClutterKnot.__init__",
					 kwlist,
					 &(knot.x), &(knot.y)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_KNOT, &knot);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_KNOT;
	
	return 0;
}
%%
override-slot ClutterKnot.tp_as_sequence
static int
_wrap_clutter_knot_length (PyGBoxed *self)
{
	return 2;
}
static PyObject *
_wrap_clutter_knot_getitem(PyGBoxed *self, int pos)
{
	ClutterKnot *knot;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 2) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	knot = pyg_boxed_get (self, ClutterKnot);
	switch (pos) {
		case 0: return PyInt_FromLong (knot->x);
		case 1: return PyInt_FromLong (knot->y);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_knot_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterKnot *knot;
	gint val;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 2) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	knot = pyg_boxed_get (self, ClutterKnot);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: knot->x = val; break;
		case 1: knot->y = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_knot_tp_as_sequence = {
	(inquiry) _wrap_clutter_knot_length,
	(binaryfunc) 0,
	(intargfunc) 0,
	(intargfunc) _wrap_clutter_knot_getitem,
	(intintargfunc) 0,
	(intobjargproc) _wrap_clutter_knot_setitem,
	(intintobjargproc) 0
};
%%
override-attr ClutterKnot.x
static int
_wrap_clutter_knot__set_x (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterKnot)->x = val;

	return 0;
}
%%
override-attr ClutterKnot.y
static int
_wrap_clutter_knot__set_y (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterKnot)->y = val;

	return 0;
}
%%
override clutter_vector_new kwargs
static int
_wrap_clutter_vector_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x", "y", "z", NULL };
	ClutterVector vector = { 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iii:ClutterVector.__init__",
					 kwlist,
					 &(vector.x), &(vector.y), &(vector.z)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_VECTOR, &vector);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_VECTOR;
	
	return 0;
}
%%
override-slot ClutterVector.tp_as_sequence
static int
_wrap_clutter_vector_length (PyGBoxed *self)
{
	return 3;
}
static PyObject *
_wrap_clutter_vector_getitem(PyGBoxed *self, int pos)
{
	ClutterVector *vector;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 3) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	vector = pyg_boxed_get (self, ClutterVector);
	switch (pos) {
		case 0: return PyInt_FromLong (vector->x);
		case 1: return PyInt_FromLong (vector->y);
		case 2: return PyInt_FromLong (vector->z);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_vector_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterVector *vector;
	gint val;

	if (pos < 0)
		pos += 1;
	
	if (pos < 0 || pos >= 3) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	vector = pyg_boxed_get (self, ClutterVector);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: vector->x = val; break;
		case 1: vector->y = val; break;
		case 2: vector->z = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_vector_tp_as_sequence = {
	(inquiry) _wrap_clutter_vector_length,
	(binaryfunc) 0,
	(intargfunc) 0,
	(intargfunc) _wrap_clutter_vector_getitem,
	(intintargfunc) 0,
	(intobjargproc) _wrap_clutter_vector_setitem,
	(intintobjargproc) 0
};
%%
override-attr ClutterVector.x
static int
_wrap_clutter_vector__set_x (PyGBoxed *self, PyObject *value, void *closure)
{
	gint32 val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterVector)->x = val;

	return 0;
}
%%
override-attr ClutterVector.y
static int
_wrap_clutter_vector__set_y (PyGBoxed *self, PyObject *value, void *closure)
{
	gint32 val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterVector)->y = val;

	return 0;
}
%%
override-attr ClutterVector.z
static int
_wrap_clutter_vector__set_z (PyGBoxed *self, PyObject *value, void *closure)
{
	gint32 val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterVector)->z = val;

	return 0;
}
