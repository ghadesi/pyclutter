%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"

#include "pyclutter-private.h"

#include <cogl/cogl.h>

static gpointer
pycogl_handle_ref (gpointer data)
{
  if (G_LIKELY (data))
    {
      CoglHandle hnd = data;

      if (hnd == COGL_INVALID_HANDLE)
        return NULL;

      if (cogl_is_texture (hnd))
        return cogl_texture_ref (hnd);
      else if (cogl_is_shader (hnd))
        return cogl_shader_ref (hnd);
      else if (cogl_is_program (hnd))
        return cogl_program_ref (hnd);
      else if (cogl_is_offscreen (hnd))
        return cogl_offscreen_ref (hnd);
      else
        g_assert_not_reached ();
    }

  return NULL;
}

static void
pycogl_handle_unref (gpointer data)
{
  if (G_LIKELY (data))
    {
      CoglHandle hnd = data;

      if (hnd == COGL_INVALID_HANDLE)
        return;

      if (cogl_is_texture (hnd))
        cogl_texture_unref (hnd);
      else if (cogl_is_shader (hnd))
        cogl_shader_unref (hnd);
      else if (cogl_is_program (hnd))
        cogl_program_unref (hnd);
      else if (cogl_is_offscreen (hnd))
        cogl_offscreen_unref (hnd);
      else
        g_assert_not_reached ();
    }
}

GType
pycogl_handle_get_type (void)
{
  static GType hnd_type = 0;

  if (G_UNLIKELY (hnd_type == 0))
    hnd_type = g_boxed_type_register_static (g_intern_static_string ("CoglHandle"),
                                             pycogl_handle_ref,
                                             pycogl_handle_unref);

  return hnd_type;
}

CoglMatrix *
pycogl_matrix_copy (const CoglMatrix *matrix)
{
    return g_slice_dup (CoglMatrix, matrix);
}

void
pycogl_matrix_free (CoglMatrix *matrix)
{
    if (G_LIKELY (matrix))
        g_slice_free (CoglMatrix, matrix);
}

GType
pycogl_matrix_get_type (void)
{
  static GType matrix_type = 0;

  if (G_UNLIKELY (matrix_type == 0))
    matrix_type = g_boxed_type_register_static (g_intern_static_string ("CoglMatrix"),
                                                (GBoxedCopyFunc) pycogl_matrix_copy,
                                                (GBoxedFreeFunc) pycogl_matrix_free);

  return matrix_type;
}

%%
include
  cogl-texture.override
  cogl-material.override
%%
modulename clutter.cogl
%%
import pango.Layout as PyPangoLayout_Type
%%
ignore
  cogl_get_modelview_matrix
  cogl_get_projection_matrix
  cogl_get_option_group
%%
override cogl_get_viewport noargs
static PyObject *
_wrap_cogl_get_viewport (PyObject *self)
{
  float viewport[4] = { 0, };

  cogl_get_viewport (viewport);

  return Py_BuildValue ("(ffff)",
                        viewport[0],
                        viewport[1],
                        viewport[2],
                        viewport[3]);
}
%%
override cogl_get_bitmasks noargs
static PyObject *
_wrap_cogl_get_bitmasks (PyObject *self)
{
  gint red, green, blue, alpha;

  cogl_get_bitmasks (&red, &green, &blue, &alpha);

  return Py_BuildValue ("(iiii)", red, green, blue, alpha);
}
%%
override cogl_bitmap_get_size_from_file
static PyObject *
_wrap_cogl_bitmap_get_size_from_file (PyObject *self,
                                      PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    const gchar *filename;
    gint width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "s:cogl.bitmap_get_size_from_file",
                                     kwlist, &filename))
        return NULL;
    
    cogl_bitmap_get_size_from_file (filename, &width, &height);

    return Py_BuildValue ("(ii)", width, height);
}
%%
override cogl_set_source_color
PyObject *
_wrap_cogl_set_source_color (PyObject *self,
                             PyObject *args,
                             PyObject *kwargs)
{
    static char *kwlist[] = { "color", NULL };
    PyObject *py_color;
    CoglColor color;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:set_source_color", kwlist,
                                     &py_color))
        return NULL;

    if (!pycogl_color_from_pyobject (py_color, &color))
    {
        PyErr_Clear ();
        PyErr_SetString (PyExc_TypeError,
                         "color must be a ClutterColor or 4-tuple");
        return NULL;
    }

    cogl_set_source_color (&color);
    Py_INCREF (Py_None);
    return Py_None;
}
%%
override cogl_material_new
static PyObject *
_wrap_cogl_material_new(PyObject *self)
{
    CoglHandle ret = COGL_INVALID_HANDLE;
    
    ret = cogl_material_new();
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(PYCOGL_TYPE_HANDLE, ret, TRUE, TRUE);
}
%%
override cogl_matrix_new noargs
static int
_wrap_cogl_matrix_new (PyGBoxed *self)
{
    CoglMatrix matrix;
    self->boxed = g_boxed_copy (PYCOGL_TYPE_MATRIX, &matrix);
    self->free_on_dealloc = TRUE;
    self->gtype = PYCOGL_TYPE_MATRIX;
    return 0;
}
