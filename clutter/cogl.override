%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"

#include "pyclutter-private.h"

#include <cogl/cogl.h>


CoglMatrix *
pycogl_matrix_copy (const CoglMatrix *matrix)
{
    return g_slice_dup (CoglMatrix, matrix);
}

void
pycogl_matrix_free (CoglMatrix *matrix)
{
    if (G_LIKELY (matrix))
        g_slice_free (CoglMatrix, matrix);
}

GType
pycogl_matrix_get_type (void)
{
  static GType matrix_type = 0;

  if (G_UNLIKELY (matrix_type == 0))
    matrix_type = g_boxed_type_register_static (g_intern_static_string ("CoglMatrix"),
                                                (GBoxedCopyFunc) pycogl_matrix_copy,
                                                (GBoxedFreeFunc) pycogl_matrix_free);

  return matrix_type;
}

GType
pycogl_color_get_type (void)
{
  static GType color_type = 0;

  if (G_UNLIKELY (color_type == 0))
    color_type = g_boxed_type_register_static (g_intern_static_string ("CoglColor"),
                                              (GBoxedCopyFunc) cogl_color_copy,
                                              (GBoxedFreeFunc) cogl_color_free);

  return color_type;
}

%%
include
  cogl-texture.override
  cogl-material.override
%%
modulename clutter.cogl
%%
import pango.Layout as PyPangoLayout_Type
import pango.LayoutLine as PyPangoLayoutLine_Type
import pangocairo.CairoFontMap as PyPangoCairoFontMap_Type
%%
ignore
  cogl_get_option_group
  cogl_get_proc_address
  cogl_color_equal
  cogl_create_program
  cogl_read_pixels
%%
ignore-glob
  cogl_fixed_*
  cogl_program_*
  cogl_vertex_*
  cogl_*_ref
  cogl_*_unref
%%
override cogl_get_viewport noargs
static PyObject *
_wrap_cogl_get_viewport (PyObject *self)
{
  float viewport[4] = { 0, };

  cogl_get_viewport (viewport);

  return Py_BuildValue ("(ffff)",
                        viewport[0],
                        viewport[1],
                        viewport[2],
                        viewport[3]);
}
%%
override cogl_get_bitmasks noargs
static PyObject *
_wrap_cogl_get_bitmasks (PyObject *self)
{
  gint red, green, blue, alpha;

  cogl_get_bitmasks (&red, &green, &blue, &alpha);

  return Py_BuildValue ("(iiii)", red, green, blue, alpha);
}
%%
override cogl_bitmap_get_size_from_file
static PyObject *
_wrap_cogl_bitmap_get_size_from_file (PyObject *self,
                                      PyObject *args,
                                      PyObject *kwargs)
{
    static char *kwlist[] = { "filename", NULL };
    const gchar *filename;
    gint width, height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "s:cogl.bitmap_get_size_from_file",
                                     kwlist, &filename))
        return NULL;
    
    cogl_bitmap_get_size_from_file (filename, &width, &height);

    return Py_BuildValue ("(ii)", width, height);
}
%%
override cogl_set_source_color
PyObject *
_wrap_cogl_set_source_color (PyObject *self,
                             PyObject *args,
                             PyObject *kwargs)
{
    static char *kwlist[] = { "color", NULL };
    PyObject *py_color;
    CoglColor color;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:set_source_color", kwlist,
                                     &py_color))
        return NULL;

    if (!pycogl_color_from_pyobject (py_color, &color))
    {
        PyErr_Clear ();
        PyErr_SetString (PyExc_TypeError,
                         "color must be a ClutterColor or 4-tuple");
        return NULL;
    }

    cogl_set_source_color (&color);
    Py_INCREF (Py_None);
    return Py_None;
}
%%
override cogl_material_new
static PyObject *
_wrap_cogl_material_new(PyObject *self)
{
    CoglHandle ret = COGL_INVALID_HANDLE;
    
    ret = cogl_material_new();
    
    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new(COGL_TYPE_HANDLE, ret, TRUE, TRUE);
}
%%
override cogl_matrix_new noargs
static int
_wrap_cogl_matrix_new (PyGBoxed *self)
{
    CoglMatrix matrix;
    self->boxed = g_boxed_copy (PYCOGL_TYPE_MATRIX, &matrix);
    self->free_on_dealloc = TRUE;
    self->gtype = PYCOGL_TYPE_MATRIX;
    return 0;
}
%%
override cogl_matrix_init_from_array
static PyObject *
_wrap_cogl_matrix_init_from_array (PyGBoxed *self, PyObject *args)
{
    PyObject *py_array;
    float array[16];
    int i;

    if (!PyArg_ParseTuple (args, "O:cogl.matrix_init_from_array", &py_array))
        return NULL;

    if (!PyTuple_Check (py_array) || PyTuple_Size (py_array) != 16)
    {
        PyErr_SetString (PyExc_TypeError,
                         "matrix_init_from_array needs a tuple of 16 floats");
        return NULL;
    }

    for (i = 0; i < 16; i++)
        array[i] = PyFloat_AsDouble (PyTuple_GetItem (py_array, i));

    cogl_matrix_init_from_array (self->boxed, array);

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override cogl_matrix_get_array noargs
static PyObject *
_wrap_cogl_matrix_get_array (PyGBoxed *self)
{
    const float *array;
    PyObject *py_array;
    int i;

    array = cogl_matrix_get_array (self->boxed);
    py_array = PyTuple_New (16);

    for (i = 0; i < 16; i++)
    {
        PyTuple_SetItem (py_array, i, PyFloat_FromDouble (array[i]));
    }

    return py_array;
}
%%
override cogl_matrix_transform_point
static PyObject *
_wrap_cogl_matrix_transform_point (PyGBoxed *self,
                                   PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "x", "y", "z", "w", NULL };
    float x, y, z, w;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ffff:Matrix.transform_point",
                                     kwlist, &x, &y, &z, &w))
        return NULL;

    cogl_matrix_transform_point (self->boxed, &x, &y, &z, &w);

    return Py_BuildValue ("(ffff)", x, y, z, w);
}
%%
new-constructor COGL_PANGO_TYPE_FONT_MAP
%%
override cogl_pango_font_map_new noargs
static int
_wrap_cogl_pango_font_map_new (PyGObject *self)
{
  self->obj = (GObject *) cogl_pango_font_map_new ();
  if (!self->obj)
    {
      PyErr_SetString (PyExc_RuntimeError, "could not create PangoFontMap");
      return -1;
    }

  g_object_ref (self->obj);
  pygobject_register_wrapper ((PyObject *) self);

  return 0;
}
%%
override cogl_pango_render_layout kwargs
static PyObject *
_wrap_cogl_pango_render_layout(PyObject *self,
                               PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "layout", "x", "y", "color", "flags", NULL };
    PyGObject *layout;
    int x, y, flags;
    CoglColor *color = NULL;
    PyObject *py_color;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!iiOi:pango_render_layout",
                                     kwlist,
                                     &PyPangoLayout_Type,
                                     &layout,
                                     &x, &y, &py_color, &flags))
        return NULL;

    if (!pycogl_color_from_pyobject (py_color, color))
    {
        PyErr_Clear ();
        PyErr_SetString (PyExc_TypeError,
                         "color must be a ClutterColor or 4-tuple");
        return NULL;
    }

    
    cogl_pango_render_layout(PANGO_LAYOUT(layout->obj), x, y, color, flags);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override cogl_pango_render_layout_subpixel
static PyObject *
_wrap_cogl_pango_render_layout_subpixel(PyObject *self,
                                        PyObject *args,
                                        PyObject *kwargs)
{
    static char *kwlist[] = { "layout", "x", "y", "color", "flags", NULL };
    PyGObject *layout;
    int x, y, flags;
    CoglColor *color = NULL;
    PyObject *py_color;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O!iiOi:pango_render_layout_subpixel",
                                     kwlist,
                                     &PyPangoLayout_Type,
                                     &layout,
                                     &x, &y, &py_color, &flags))
        return NULL;

    if (!pycogl_color_from_pyobject (py_color, color))
    {
        PyErr_Clear ();
        PyErr_SetString (PyExc_TypeError,
                         "color must be a ClutterColor or 4-tuple");
        return NULL;
    }

    
    cogl_pango_render_layout_subpixel(PANGO_LAYOUT(layout->obj), x, y, color, flags);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override cogl_pango_render_layout_line kwargs
static PyObject *
_wrap_cogl_pango_render_layout_line(PyObject *self,
                                    PyObject *args,
                                    PyObject *kwargs)
{
    static char *kwlist[] = { "line", "x", "y", "color", NULL };
    PangoLayoutLine *line = NULL;
    PyObject *py_line, *py_color;
    int x, y;
    CoglColor *color = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OiiO:pango_render_layout_line",
                                     kwlist, &py_line, &x, &y, &py_color))
        return NULL;
    if (pyg_boxed_check(py_line, PANGO_TYPE_LAYOUT_LINE))
        line = pyg_boxed_get(py_line, PangoLayoutLine);
    else {
        PyErr_SetString(PyExc_TypeError, "line should be a PangoLayoutLine");
        return NULL;
    }
    
    if (!pycogl_color_from_pyobject (py_color, color))
    {
        PyErr_Clear ();
        PyErr_SetString (PyExc_TypeError,
                         "color must be a ClutterColor or 4-tuple");
        return NULL;
    }

    cogl_pango_render_layout_line(line, x, y, color);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override cogl_set_fog kwargs
static PyObject *
_wrap_cogl_set_fog(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "fog_color", "mode", "density", "z_near", "z_far", NULL };
    CoglColor *fog_color = NULL;
    PyObject *py_fog_color, *py_mode = NULL;
    double density, z_near, z_far;
    CoglFogMode mode;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OOddd:set_fog", kwlist, &py_fog_color, &py_mode, &density, &z_near, &z_far))
        return NULL;

    if (!pycogl_color_from_pyobject (py_fog_color, fog_color))
    {
        PyErr_Clear ();
        PyErr_SetString (PyExc_TypeError,
                         "color must be a ClutterColor or 4-tuple");
        return NULL;
    }

    if (pyg_enum_get_value(COGL_TYPE_FOG_MODE, py_mode, (gpointer)&mode))
        return NULL;
    
    cogl_set_fog(fog_color, mode, density, z_near, z_far);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override cogl_clear kwargs
static PyObject *
_wrap_cogl_clear(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "color", "buffers", NULL };
    CoglColor *color = NULL;
    PyObject *py_color;
    unsigned long buffers;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"Ok:clear", kwlist, &py_color, &buffers))
        return NULL;

    if (!pycogl_color_from_pyobject (py_color, color))
    {
        PyErr_Clear ();
        PyErr_SetString (PyExc_TypeError,
                         "color must be a ClutterColor or 4-tuple");
        return NULL;
    }

    cogl_clear(color, buffers);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override cogl_get_modelview_matrix noargs
static PyObject *
_wrap_cogl_get_modelview_matrix (PyObject *self)
{
    CoglMatrix matrix;

    cogl_get_modelview_matrix (&matrix);

    return pyg_boxed_new (PYCOGL_TYPE_MATRIX, &matrix, TRUE, TRUE);
}
%%
override cogl_get_projection_matrix noargs
static PyObject *
_wrap_cogl_get_projection_matrix (PyObject *self)
{
    CoglMatrix matrix;

    cogl_get_projection_matrix (&matrix);

    return pyg_boxed_new (PYCOGL_TYPE_MATRIX, &matrix, TRUE, TRUE);
}
