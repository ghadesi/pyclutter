%%
ignore
  clutter_alpha_new_full
  clutter_alpha_new_with_func
  clutter_alpha_set_closure
  clutter_path_foreach
  clutter_path_add_cairo_path
  clutter_behaviour_path_new_with_knots
  clutter_actor_animatev
  clutter_actor_animate_with_timelinev
  clutter_actor_animate_with_alphav
%%
override clutter_alpha_set_func kwargs
static PyObject *
_wrap_clutter_alpha_set_func (PyGObject *self,
                              PyObject  *args,
                              PyObject  *kwargs)
{
        static char *kwlist[] = { "func", "data", NULL };
        PyObject *py_func, *py_data = NULL;
        ClutterAlpha *alpha;
        PyClutterCallback *pycb;
        GType param_types[] = { CLUTTER_TYPE_ALPHA };
        gint n_params = G_N_ELEMENTS (param_types);

        if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                         "O|O:clutter.Alpha.set_func",
                                         kwlist,
                                         &py_func, &py_data)) {
                return NULL;
        }

        if (!PyCallable_Check (py_func)) {
                PyErr_SetString (PyExc_TypeError, "func must be callable");
                return NULL;
        }

        pycb = pyclutter_callback_new (py_func, py_data,
                                       n_params, param_types);

        alpha = CLUTTER_ALPHA (self->obj);
        clutter_alpha_set_func (alpha,
                                pyclutter_alpha_func, pycb,
                                (GDestroyNotify) pyclutter_callback_free);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_alpha_register_func kwargs
static PyObject *
_wrap_clutter_alpha_register_func (PyObject *self,
                              PyObject  *args,
                              PyObject  *kwargs)
{
        static char *kwlist[] = { "func", "data", NULL };
        PyObject *py_func, *py_data = NULL;
        PyClutterCallback *pycb;
        gulong id;
        GType param_types[] = { CLUTTER_TYPE_ALPHA };
        gint n_params = G_N_ELEMENTS (param_types);

        if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                         "O|O:clutter.alpha_register_func",
                                         kwlist,
                                         &py_func, &py_data)) {
                return NULL;
        }

        if (!PyCallable_Check (py_func)) {
                PyErr_SetString (PyExc_TypeError, "func must be callable");
                return NULL;
        }

        pycb = pyclutter_callback_new (py_func, py_data,
                                       n_params, param_types);

        id = clutter_alpha_register_func (pyclutter_alpha_func, pycb);

        return Py_BuildValue("K", id);
}
%%
override clutter_behaviour_actors_foreach kwargs
static void
pyclutter_behaviour_foreach (ClutterBehaviour *behaviour,
                             ClutterActor     *actor,
                             gpointer          data)
{
        PyClutterCallback *pycb = data;
        PyGILState_STATE state;
        PyObject *py_behaviour, *py_actor;
        PyObject *retobj;

        state = pyg_gil_state_ensure ();

        py_behaviour = pygobject_new ((GObject *) behaviour);
        py_actor = pygobject_new ((GObject *) actor);
        retobj = pyclutter_callback_invoke (pycb, py_behaviour, py_actor);
        if (retobj == NULL)
                PyErr_Print ();

        Py_XDECREF (retobj);

        pyg_gil_state_release (state);
}
static PyObject *
_wrap_clutter_behaviour_actors_foreach (PyGObject *self,
                                        PyObject  *args,
                                        PyObject  *kwargs)
{
        static char *kwlist[] = { "func", "data", NULL };
        PyObject *py_func, *py_data = NULL;
        ClutterBehaviour *behaviour;
        PyClutterCallback *pycb;
        GType param_types[] = {
                CLUTTER_TYPE_BEHAVIOUR,
                CLUTTER_TYPE_ALPHA,
        };
        gint n_params = G_N_ELEMENTS (param_types);

        if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                         "O|O:clutter.Behaviour.actor_foreach",
                                         kwlist,
                                         &py_func, &py_data)) {
                return NULL;
        }

        if (!PyCallable_Check (py_func)) {
                PyErr_SetString (PyExc_TypeError, "func must be callable");
                return NULL;
        }

        pycb = pyclutter_callback_new (py_func, py_data,
                                       n_params, param_types);
        behaviour = CLUTTER_BEHAVIOUR (self->obj);

        clutter_behaviour_actors_foreach (behaviour,
                                          pyclutter_behaviour_foreach,
                                          pycb);

        pyclutter_callback_free (pycb);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_behaviour_get_actors
static PyObject *
_wrap_clutter_behaviour_get_actors (PyGObject *self,
                                    PyObject  *args)
{
        GSList *actors, *l;
        PyObject *py_list;

        actors = clutter_behaviour_get_actors (CLUTTER_BEHAVIOUR (self->obj));

        if ((py_list = PyList_New (0)) == NULL) {
                g_slist_free (actors);
                return NULL;
        }

        for (l = actors; l != NULL; l = l->next) {
                ClutterActor *actor = l->data;
                PyObject *py_actor;

                py_actor = pygobject_new ((GObject *) actor);
                if (!py_actor) {
                        g_slist_free (actors);
                        Py_DECREF (py_list);
                        return NULL;
                }

                PyList_Append (py_list, py_actor);
                Py_DECREF (py_actor);
        }

        g_slist_free (actors);

        return py_list;
}
%%
override ClutterBehaviour__proxy_do_alpha_notify
static void
_wrap_ClutterBehaviour__proxy_do_alpha_notify (ClutterBehaviour *behaviour,
                                               gdouble           alpha_value)
{
        PyGILState_STATE state;
        PyObject *py_self;
        PyObject *py_method, *py_args;
        PyObject *py_ret, *py_alpha;
        
        state = pyg_gil_state_ensure ();

        py_self = pygobject_new ((GObject *) behaviour);
        if (!py_self) {
                if (PyErr_Occurred ())
                        PyErr_Print ();

                pyg_gil_state_release (state);
                return;
        }

        py_alpha = PyFloat_FromDouble (alpha_value);
        if (!py_alpha) {
                if (PyErr_Occurred ())
                        PyErr_Print ();

                Py_DECREF (py_self);

                pyg_gil_state_release (state);
                return;
        }

        py_args = PyTuple_New (1);
        PyTuple_SET_ITEM (py_args, 0, py_alpha);

        py_method = PyObject_GetAttrString (py_self, "do_alpha_notify");
        if (!py_method) {
                if (PyErr_Occurred ())
                        PyErr_Print ();
                
                Py_DECREF (py_args);
                Py_DECREF (py_self);

                pyg_gil_state_release (state);
                return;
        }

        py_ret = PyObject_CallObject (py_method, py_args);
        if (!py_ret) {
                if (PyErr_Occurred ())
                        PyErr_Print ();

                Py_DECREF (py_method);
                Py_DECREF (py_args);
                Py_DECREF (py_self);

                pyg_gil_state_release (state);
                return;
        }
        
        if (py_ret != Py_None) {
                PyErr_SetString (PyExc_TypeError, "retval should be None");
                PyErr_Print();
                
                Py_DECREF (py_ret);
                Py_DECREF (py_method);
                Py_DECREF (py_args);
                Py_DECREF (py_self);
                
                pyg_gil_state_release (state);
                return;
        }

        Py_DECREF (py_ret);
        Py_DECREF (py_method);
        Py_DECREF (py_args);
        Py_DECREF (py_self);

        pyg_gil_state_release (state);
}
%%
override ClutterBehaviour__do_alpha_notify kwargs
static PyObject *
_wrap_ClutterBehaviour__do_alpha_notify (PyObject *cls,
                                         PyObject *args,
                                         PyObject *kwargs)
{
        gpointer klass;
        static char *kwlist[] = { "self", "alpha", NULL };
        PyGObject *self;
        PyObject *py_alpha;
        gdouble alpha_value = 0.0;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "OO:ClutterBehaviour.alpha_notify",
                                          kwlist,
                                          &PyClutterBehaviour_Type, &self,
                                          &py_alpha))
                return NULL;

        if (py_alpha) {
                if (PyFloat_Check (py_alpha))
                        alpha_value = (gdouble) PyFloat_AsDouble (py_alpha);
                else
                        PyErr_SetString (PyExc_TypeError,
                                         "Parameter 'alpha' must be an int or a long");

                if (PyErr_Occurred ())
                        return NULL;
        }

        klass = g_type_class_ref (pyg_type_from_object (cls));
        if (CLUTTER_BEHAVIOUR_CLASS (klass)->alpha_notify) {
                ClutterBehaviour *behaviour;
                
                behaviour = CLUTTER_BEHAVIOUR (self->obj);
                CLUTTER_BEHAVIOUR_CLASS (klass)->alpha_notify (behaviour,
                                                               alpha_value);
        }
        else {
                PyErr_SetString (PyExc_NotImplementedError,
                                 "virtual method ClutterBehaviour.alpha_notify not implemented");
                g_type_class_unref (klass);
                return NULL;
        }

        g_type_class_unref (klass);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
new-constructor CLUTTER_TYPE_BEHAVIOUR_ELLIPSE
%%
override clutter_behaviour_ellipse_new kwargs
static int
_wrap_clutter_behaviour_ellipse_new (PyGObject *self,
                                     PyObject  *args,
                                     PyObject  *kwargs)
{
        static char *kwlist[] = { "alpha", "x", "y", "width", "height", "start", "end", NULL};
        PyObject *py_alpha = Py_None;
        int x, y, width, height;
        double start, end;
        ClutterKnot center = { 0, };
        ClutterAlpha *alpha;

        /* these are the default values from the properties */
        x = y = 0; /* center */
        width = 100;
        height = 50;
        start = 0.0;
        end = 360.0;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "|Oiiiidd:clutter.BehaviourEllipse.__init__",
                                          kwlist,
                                          &py_alpha,
                                          &x, &y, &width, &height,
                                          &start, &end))
                return -1;
        
        if (py_alpha == Py_None)
                alpha = NULL;
        else if (pygobject_check (py_alpha, &PyClutterAlpha_Type))
                alpha = CLUTTER_ALPHA (pygobject_get (py_alpha));
        else {
                PyErr_SetString (PyExc_TypeError,
                                 "first argument must be a ClutterAlpha or None");
                return -1;
        }

        center.x = x;
        center.y = y;

        pygobject_construct (self,
                             "alpha", alpha,
                             "center", &center,
                             "width", width,
                             "height", height,
                             "angle-start", start,
                             "angle-end", end,
                             NULL);

        return 0;
}
%%
override clutter_behaviour_ellipse_get_center noargs
static PyObject *
_wrap_clutter_behaviour_ellipse_get_center (PyGObject *self)
{
        ClutterBehaviourEllipse *ellipse;
        gint center_x, center_y;

        ellipse = CLUTTER_BEHAVIOUR_ELLIPSE (self->obj);
        clutter_behaviour_ellipse_get_center (ellipse, &center_x, &center_y);

        return Py_BuildValue ("(ii)", center_x, center_y);
}
%%
override clutter_behaviour_ellipse_get_tilt noargs
static PyObject *
_wrap_clutter_behaviour_ellipse_get_tilt (PyGObject *self)
{
        ClutterBehaviourEllipse *ellipse;
        gdouble tilt_x, tilt_y, tilt_z;

        ellipse = CLUTTER_BEHAVIOUR_ELLIPSE (self->obj);
        clutter_behaviour_ellipse_get_tilt (ellipse, &tilt_x, &tilt_y, &tilt_z);

        return Py_BuildValue ("(ddd)", tilt_x, tilt_y, tilt_z);
}
%%
override clutter_behaviour_rotate_get_center noargs
static PyObject *
_wrap_clutter_behaviour_rotate_get_center (PyGObject *self)
{
        ClutterBehaviourRotate *rotate;
        gint center_x, center_y, center_z;

        rotate = CLUTTER_BEHAVIOUR_ROTATE (self->obj);
        clutter_behaviour_rotate_get_center (rotate, &center_x, &center_y, &center_z);

        return Py_BuildValue ("(iii)", center_x, center_y, center_z);
}
%%
override clutter_behaviour_rotate_get_bounds noargs
static PyObject *
_wrap_clutter_behaviour_rotate_get_bounds (PyGObject *self)
{
        ClutterBehaviourRotate *rotate;
        gdouble start, end;

        rotate = CLUTTER_BEHAVIOUR_ROTATE (self->obj);
        clutter_behaviour_rotate_get_bounds (rotate, &start, &end);

        return Py_BuildValue ("(dd)", start, end);
}
%%
override clutter_behaviour_scale_get_bounds noargs
static PyObject *
_wrap_clutter_behaviour_scale_get_bounds (PyGObject *self)
{
        ClutterBehaviourScale *scale;
        gdouble x_start, x_end;
        gdouble y_start, y_end;

        scale = CLUTTER_BEHAVIOUR_SCALE (self->obj);
        clutter_behaviour_scale_get_bounds (scale,
                                            &x_start, &y_start,
                                            &x_end, &y_end);

        return Py_BuildValue ("(dddd)", x_start, y_start, x_end, y_end);
}
%%
override clutter_behaviour_depth_get_bounds noargs
static PyObject *
_wrap_clutter_behaviour_depth_get_bounds (PyGObject *self)
{
        ClutterBehaviourDepth *depth;
        gint start, end;

        depth = CLUTTER_BEHAVIOUR_DEPTH (self->obj);
        clutter_behaviour_depth_get_bounds (depth, &start, &end);

        return Py_BuildValue ("(ii)", start, end);
}
%%
override clutter_behaviour_opacity_get_bounds noargs
static PyObject *
_wrap_clutter_behaviour_opacity_get_bounds (PyGObject *self)
{
        ClutterBehaviourOpacity *opacity;
        guint8 start, end;

        opacity = CLUTTER_BEHAVIOUR_OPACITY (self->obj);
        clutter_behaviour_opacity_get_bounds (opacity, &start, &end);

        return Py_BuildValue ("(KK)", start, end);
}
%%
override clutter_path_get_nodes noargs
static PyObject *
_wrap_clutter_path_get_nodes (PyGObject *self)
{
        GSList *nodes, *l;
        PyObject *py_list;

        nodes = clutter_path_get_nodes (CLUTTER_PATH (self->obj));

        if ((py_list = PyList_New (0)) == NULL) {
                g_slist_free (nodes);
                return NULL;
        }

        for (l = nodes; l != NULL; l = l->next) {
                ClutterPathNode *node = l->data;
                PyObject *py_node;

                //py_node = pygobject_new ((GObject *) actor);
                py_node = pyg_boxed_new (CLUTTER_TYPE_PATH_NODE, node, TRUE, TRUE);
                if (!py_node) {
                        g_slist_free (nodes);
                        Py_DECREF (py_list);
                        return NULL;
                }

                PyList_Append (py_list, py_node);
                Py_DECREF (py_node);
        }

        g_slist_free (nodes);

        return py_list;
}
%%
override clutter_actor_animate
static PyObject *
_wrap_clutter_actor_animate (PyGObject *self,
                             PyObject  *args)
{
    ClutterActor *actor;
    GObjectClass *klass;
    gulong mode;
    guint n, p, i, len, duration;
    gchar **properties;
    GValueArray *values;
    ClutterAnimation *animation;

    len = PyTuple_Size (args);
    if (len < 4 || (len % 2) != 0)
        goto out;

    if (!PyInt_Check (PyTuple_GetItem (args, 0)))
        goto out;

    if (!PyInt_Check (PyTuple_GetItem (args, 1)))
        goto out;

    mode = PyInt_AsLong (PyTuple_GetItem (args, 0));
    duration = PyInt_AsLong (PyTuple_GetItem (args, 1));

    actor = CLUTTER_ACTOR (self->obj);
    klass = G_OBJECT_GET_CLASS (self->obj);

    n = (len - 2) / 2;

    properties = g_new0 (gchar*, n);
    values = g_value_array_new (n);

    for (i = 2, p = 0; i < len; i += 2, p++) {
        PyObject *py_value = NULL;
        GParamSpec *pspec;
        GValue value = { 0, };

        if (!PyString_Check (PyTuple_GetItem (args, i))) {
            PyErr_SetString (PyExc_TypeError, "propertyname is not a string");
            g_free (properties);
            return NULL;
        }

        properties[p] = PyString_AsString (PyTuple_GetItem (args, i));
        pspec = g_object_class_find_property (klass, properties[p]);
        if (!pspec) {
            PyErr_Format (PyExc_TypeError,
                          "Class %s has no property %s",
                          G_OBJECT_CLASS_NAME (klass),
                          properties[p]);
            g_free (properties);
            return NULL;
        }

        g_value_init (&value, G_PARAM_SPEC_VALUE_TYPE (pspec));

        py_value = PyTuple_GetItem (args, i + 1);
        if (pyg_value_from_pyobject (&value, py_value)) {
            PyErr_Format (PyExc_TypeError,
                          "Wrong value type for property %s (required %s)",
                          properties[p],
                          g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspec)));
            g_value_unset (&value);
            g_free (properties);
            return NULL;
        }

        g_value_array_append (values, &value);
        g_value_unset (&value);
    }

    animation = clutter_actor_animatev (actor, mode, duration, n,
                                        (const gchar**) properties,
                                        values->values);

    g_free (properties);
    g_value_array_free (values);

    return pygobject_new ((GObject *)animation);

out:
    PyErr_Clear ();
    PyErr_SetString (PyExc_TypeError,
                     "clutter.Actor.animate requires an AnimationMode, "
                     "duration and at least one pair of property/value.");
    return NULL;
}
%%
override clutter_actor_animate_with_timeline
static PyObject *
_wrap_clutter_actor_animate_with_timeline (PyGObject *self,
                                           PyObject  *args)
{
    ClutterActor *actor;
    GObjectClass *klass;
    gulong mode;
    guint n, p, i, len;
    gchar **properties;
    GValueArray *values;
    ClutterTimeline *timeline;
    ClutterAnimation *animation;

    len = PyTuple_Size (args);
    if (len < 4 || (len % 2) != 0)
        goto out;

    if (!PyInt_Check (PyTuple_GetItem (args, 0)))
        goto out;

    if (!pygobject_check (PyTuple_GetItem (args, 1), &PyClutterTimeline_Type))
        goto out;

    mode = PyInt_AsLong (PyTuple_GetItem (args, 0));
    timeline = CLUTTER_TIMELINE (pygobject_get (PyTuple_GetItem (args, 1)));

    actor = CLUTTER_ACTOR (self->obj);
    klass = G_OBJECT_GET_CLASS (self->obj);

    n = (len - 2) / 2;

    properties = g_new0 (gchar*, n);
    values = g_value_array_new (n);

    for (i = 2, p = 0; i < len; i += 2, p++) {
        PyObject *py_value = NULL;
        GParamSpec *pspec;
        GValue value = { 0, };

        if (!PyString_Check (PyTuple_GetItem (args, i))) {
            PyErr_SetString (PyExc_TypeError, "propertyname is not a string");
            g_free (properties);
            return NULL;
        }

        properties[p] = PyString_AsString (PyTuple_GetItem (args, i));
        pspec = g_object_class_find_property (klass, properties[p]);
        if (!pspec) {
            PyErr_Format (PyExc_TypeError,
                          "Class %s has no property %s",
                          G_OBJECT_CLASS_NAME (klass),
                          properties[p]);
            g_free (properties);
            return NULL;
        }

        g_value_init (&value, G_PARAM_SPEC_VALUE_TYPE (pspec));

        py_value = PyTuple_GetItem (args, i + 1);
        if (pyg_value_from_pyobject (&value, py_value)) {
            PyErr_Format (PyExc_TypeError,
                          "Wrong value type for property %s (required %s)",
                          properties[p],
                          g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspec)));
            g_free (properties);
            g_value_unset (&value);
            return NULL;
        }

        g_value_array_append (values, &value);
        g_value_unset (&value);
    }

    animation = clutter_actor_animate_with_timelinev (actor, mode, timeline, n,
                                                     (const gchar**) properties,
                                                      values->values);

    g_free (properties);
    g_value_array_free (values);

    return pygobject_new ((GObject *)animation);

out:
    PyErr_Clear ();
    PyErr_SetString (PyExc_TypeError,
                     "clutter.Actor.animate_with_timeline requires an "
                     "AnimationMode, a ClutterTimeline and at least one "
                     "pair of property/value.");
    return NULL;
}
%%
override clutter_actor_animate_with_alpha
static PyObject *
_wrap_clutter_actor_animate_with_alpha (PyGObject *self,
                                        PyObject  *args)
{
    ClutterActor *actor;
    GObjectClass *klass;
    guint n, p, i, len;
    gchar **properties;
    GValueArray *values;
    ClutterAlpha *alpha;
    ClutterAnimation *animation;

    len = PyTuple_Size (args);
    if (len < 3 || (len % 2) == 0)
        goto out;

    if (!pygobject_check (PyTuple_GetItem (args, 0), &PyClutterAlpha_Type))
        goto out;

    alpha = CLUTTER_ALPHA (pygobject_get (PyTuple_GetItem (args, 0)));

    actor = CLUTTER_ACTOR (self->obj);
    klass = G_OBJECT_GET_CLASS (self->obj);

    n = (len - 1) / 2;

    properties = g_new0 (gchar*, n);
    values = g_value_array_new (n);

    for (i = 1, p = 0; i < len; i += 2, p++) {
        PyObject *py_value = NULL;
        GParamSpec *pspec;
        GValue value = { 0, };

        if (!PyString_Check (PyTuple_GetItem (args, i))) {
            PyErr_SetString (PyExc_TypeError, "propertyname is not a string");
            g_free (properties);
            return NULL;
        }

        properties[p] = PyString_AsString (PyTuple_GetItem (args, i));
        pspec = g_object_class_find_property (klass, properties[p]);
        if (!pspec) {
            PyErr_Format (PyExc_TypeError,
                          "Class %s has no property %s",
                          G_OBJECT_CLASS_NAME (klass),
                          properties[p]);
            g_free (properties);
            return NULL;
        }

        g_value_init (&value, G_PARAM_SPEC_VALUE_TYPE (pspec));

        py_value = PyTuple_GetItem (args, i + 1);
        if (pyg_value_from_pyobject (&value, py_value)) {
            PyErr_Format (PyExc_TypeError,
                          "Wrong value type for property %s (required %s)",
                          properties[p],
                          g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspec)));
            g_free (properties);
            g_value_unset (&value);
            return NULL;
        }

        g_value_array_append (values, &value);
        g_value_unset (&value);
    }

    animation = clutter_actor_animate_with_alphav (actor, alpha, n,
                                                  (const gchar**) properties,
                                                  values->values);

    g_free (properties);
    g_value_array_free (values);

    return pygobject_new ((GObject *)animation);

out:
    PyErr_Clear ();
    PyErr_SetString (PyExc_TypeError,
                     "clutter.Actor.animate_with_alpha requires an "
                     "AnimationMode, a ClutterAlpha and at least one "
                     "pair of property/value.");
    return NULL;
}
%%
override clutter_animation_bind kwargs
static PyObject *
_wrap_clutter_animation_bind (PyGObject *self,
                              PyObject  *args,
                              PyObject  *kwargs)
{

    static char *kwlist[] = { "property_name", "value", NULL };
    gchar *property_name;
    PyObject *py_value;
    ClutterAnimation *anim;
    GObjectClass *klass;
    GParamSpec *pspec;
    GValue value = { 0, };

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                      "sO:clutter.Animation.bind",
                                      kwlist,
                                      &property_name, &py_value))
        return NULL;

    anim = CLUTTER_ANIMATION (self->obj);
    klass = G_OBJECT_GET_CLASS (clutter_animation_get_object (anim));
    pspec = g_object_class_find_property (klass, property_name);

    if (!pspec) {
        PyErr_Format (PyExc_TypeError,
                      "Controlled object %s has no property %s",
                      G_OBJECT_CLASS_NAME (klass), property_name);
        return NULL;
    }

    g_value_init (&value, G_PARAM_SPEC_VALUE_TYPE (pspec));

    if (pyg_value_from_pyobject (&value, py_value)) {
        PyErr_Format (PyExc_TypeError,
                      "Wrong value type for property %s (required %s)",
                      property_name,
                      g_type_name (G_PARAM_SPEC_VALUE_TYPE (pspec)));
        g_value_unset (&value);
        return NULL;
    }
    
    clutter_animation_bind (anim, property_name, &value);

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override ClutterAnimatable__proxy_do_animate_property kwargs
static gboolean
_wrap_ClutterAnimatable__proxy_do_animate_property(ClutterAnimatable *self,
                                                   ClutterAnimation *animation,
                                                   const gchar *property_name,
                                                   const GValue *initial_value,
                                                   const GValue *final_value,
                                                   gdouble progress,
                                                   GValue* value)
{
    PyGILState_STATE __py_state;
    PyObject *py_self;
    PyObject *py_animation = NULL;
    PyObject *py_property_name;
    PyObject *py_initial_value = NULL;
    PyObject *py_final_value = NULL;
    PyObject *py_progress;
    gboolean retval;
    PyObject *py_main_retval;
    PyObject *py_retval;
    PyObject *py_args;
    PyObject *py_method;

    __py_state = pyg_gil_state_ensure();
    py_self = pygobject_new((GObject *) self);
    if (!py_self) {
        if (PyErr_Occurred())
            PyErr_Print();
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (animation)
        py_animation = pygobject_new((GObject *) animation);
    else {
        Py_INCREF(Py_None);
        py_animation = Py_None;
    }
    py_property_name = PyString_FromString(property_name);
    if (!py_property_name) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_animation);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    if (initial_value)
        py_initial_value = pyg_value_as_pyobject (initial_value, TRUE);
    else {
        Py_INCREF(Py_None);
        py_initial_value = Py_None;
    }
    if (final_value)
        py_final_value = pyg_value_as_pyobject (final_value, TRUE);
    else {
        Py_INCREF(Py_None);
        py_final_value = Py_None;
    }
    py_progress = PyFloat_FromDouble(progress);

    py_args = PyTuple_New(5);
    PyTuple_SET_ITEM(py_args, 0, py_animation);
    PyTuple_SET_ITEM(py_args, 1, py_property_name);
    PyTuple_SET_ITEM(py_args, 2, py_initial_value);
    PyTuple_SET_ITEM(py_args, 3, py_final_value);
    PyTuple_SET_ITEM(py_args, 4, py_progress);

    py_method = PyObject_GetAttrString(py_self, "do_animate_property");
    if (!py_method) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = PyObject_CallObject(py_method, py_args);
    if (!py_retval) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }
    py_retval = Py_BuildValue("(N)", py_retval);
    if (!PyArg_ParseTuple(py_retval, "O", &py_main_retval)) {
        if (PyErr_Occurred())
            PyErr_Print();
        Py_XDECREF(py_retval);
        Py_DECREF(py_method);
        Py_DECREF(py_args);
        Py_DECREF(py_self);
        pyg_gil_state_release(__py_state);
        return FALSE;
    }

    pyg_value_from_pyobject (value, py_main_retval);
    if (py_main_retval == Py_None)
        retval = FALSE;
    else
        retval = TRUE;

    Py_XDECREF(py_retval);
    Py_DECREF(py_method);
    Py_DECREF(py_args);
    Py_DECREF(py_self);
    pyg_gil_state_release(__py_state);

    return retval;
}
%%
override ClutterAnimatable__do_animate_property kwargs
static PyObject *
_wrap_ClutterAnimatable__do_animate_property(PyObject *cls,
                                             PyObject *args,
                                             PyObject *kwargs)
{
    ClutterAnimatableIface *iface;
    static char *kwlist[] = { "self", "animation", "property_name", "initial_value", "final_value", "progress", NULL };
    PyGObject *self, *animation;
    char *property_name;
    PyObject *py_initial_value, *py_final_value;
    int ret;
    double progress;
    GValue initial = { 0, };
    GValue final = { 0, };
    GValue value = { 0, };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!O!sOOd:ClutterAnimatable.animate_property",
                                     kwlist,
                                     &PyClutterAnimatable_Type, &self,
                                     &PyClutterAnimation_Type, &animation,
                                     &property_name,
                                     &py_initial_value, &py_final_value,
                                     &progress))
        return NULL;

    iface = g_type_interface_peek(g_type_class_peek(pyg_type_from_object(cls)),
                                  CLUTTER_TYPE_ANIMATABLE);

    if (iface->animate_property) {
        GParamSpec *pspec;
        pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (self->obj),
                                              property_name);
        g_value_init (&initial, G_PARAM_SPEC_VALUE_TYPE (pspec));
        g_value_init (&final, G_PARAM_SPEC_VALUE_TYPE (pspec));
        g_value_init (&value, G_PARAM_SPEC_VALUE_TYPE (pspec));
        pyg_value_from_pyobject (&initial, py_initial_value);
        pyg_value_from_pyobject (&final, py_final_value);
        ret = iface->animate_property (CLUTTER_ANIMATABLE (self->obj),
                                       CLUTTER_ANIMATION (animation->obj),
                                       property_name,
                                       &initial,
                                       &final,
                                       progress,
                                       &value);
    } else {
        PyErr_SetString(PyExc_NotImplementedError, "interface method ClutterAnimatable.animate_property not implemented");
        return NULL;
    }
    return PyBool_FromLong(ret);

}
