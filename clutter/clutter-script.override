%%
headers

typedef struct {
    PyObject    *obj;
    PyObject    *data;
} PyGCustomSignalNotify;

%%
ignore
  clutter_scriptable_set_id
  clutter_scriptable_get_id
  clutter_scriptable_parse_custom_node
  clutter_scriptable_set_custom_property
%%
ignore clutter_script_connect_signals_full
%%
override clutter_script_connect_signals kwargs
static void
connect_many (ClutterScript *script,
              GObject *obj,
              const gchar *signal_name,
              const gchar *handler_name,
              GObject *connect_object,
              GConnectFlags flags,
              gpointer user_data)
{
    PyGCustomSignalNotify   *notify = user_data;
    PyObject                *handler_dict = notify->obj;
    PyObject                *tuple, *self;
    GClosure                *closure = NULL;

    tuple = PyMapping_GetItemString (handler_dict, (gchar *) handler_name);
    if (!tuple) {
        PyErr_Clear ();
        tuple = PyObject_GetAttrString (handler_dict, (gchar *) handler_name);
        if (!tuple) {
            PyErr_Clear ();
            return;
        }
    }
    
    if (PyTuple_Check (tuple)) {
        PyObject *callback = PyTuple_GetItem (tuple, 0);
        PyObject *extra = PySequence_GetSlice (tuple, 1, PyTuple_Size (tuple));
        PyObject *other = NULL;

        if (connect_object)
            other = pygobject_new ((GObject *) connect_object);

        closure = pyg_closure_new (callback, extra, other);
        Py_DECREF (extra);
    } else if (PyCallable_Check (tuple)) {
        PyObject *other = NULL;

        if (connect_object)
            other = pygobject_new ((GObject *) connect_object);

        closure = pyg_closure_new (tuple, notify->data, other);
    } else {
        g_warning ("handler for `%s' not callable or a tuple", handler_name);
        Py_DECREF (tuple);
        return;
    }

    Py_DECREF (tuple);

    self = pygobject_new (obj);
    g_signal_connect_closure (obj, signal_name, closure, flags);
    pygobject_watch_closure (self, closure);
    
    Py_DECREF (self);
}
static PyObject *
_wrap_clutter_script_connect_signals (PyGObject *self,
                                      PyObject  *args,
                                      PyObject  *kwargs)
{
    static char *kwlist[] = { "object", "user_data", NULL };
    PyGCustomSignalNotify   notify;
    PyObject                *object, *user_data = NULL;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O:clutter.Script.connect_signals",
                                     kwlist,
                                     &object, &user_data))
        return NULL;

    notify.obj = object;
    notify.data = user_data;

    clutter_script_connect_signals_full (CLUTTER_SCRIPT (self->obj),
                                         connect_many,
                                         &notify);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override clutter_script_get_objects
static PyObject *
_wrap_clutter_script_get_objects (PyGObject *self,
                                  PyObject  *args)
{
    int len, i;
    PyObject *retval;

    if (!PyTuple_Check (args)) {
        PyErr_SetString (PyExc_TypeError, "expecting a tuple of names");
        return NULL;
    }

    len = PyTuple_Size (args);
    retval = PyList_New (0);

    for (i = 0; i < len; i++) {
        PyObject *py_name, *item;
        GObject *res;

        py_name = PyTuple_GetItem (args, i);
        if (!PyString_Check (py_name)) {
            PyErr_SetString (PyExc_TypeError, "expecting a string");
            Py_DECREF (retval);
            return NULL;
        }

        res = clutter_script_get_object (CLUTTER_SCRIPT (self->obj),
                                         PyString_AsString (py_name));
        if (!res) {
            g_warning ("Unable to find `%s'", PyString_AsString (py_name));
            continue;
        }

        item = pygobject_new (res);
        PyList_Append (retval, item);
        Py_DECREF (item);
    }

    return retval;
}
%%
override clutter_script_add_search_paths
static PyObject *
_wrap_clutter_script_add_search_paths (PyGObject *self,
                                       PyObject  *args)
{
    int len, i;
    gchar **paths;

    if (!PyTuple_Check (args)) {
        PyErr_SetString (PyExc_TypeError, "expecting a tuple of paths");
        return NULL;
    }

    len = PyTuple_Size (args);
    paths = g_new0 (gchar*, len + 1);

    for (i = 0; i < len; i++) {
        PyObject *py_path;

        py_path = PyTuple_GetItem (args, i);
        if (!PyString_Check (py_path)) {
            PyErr_SetString (PyExc_TypeError, "expecting a string");
            g_strfreev (paths);
            return NULL;
        }

        paths[i] = g_strdup (PyString_AsString (py_path));
    }

    clutter_script_add_search_paths (CLUTTER_SCRIPT (self->obj),
                                     (const gchar **) paths,
                                     len);

    g_strfreev (paths);

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override clutter_script_list_objects noargs
static PyObject *
_wrap_clutter_script_list_objects (PyGObject *self)
{
#if CLUTTER_CHECK_VERSION(0, 8, 2)
    GList *objects, *l;
    PyObject *py_list;

    objects = clutter_script_list_objects (CLUTTER_SCRIPT (self->obj));

    if ((py_list = PyList_New (0)) == NULL) {
        g_list_free (objects);
        return NULL;
    }

    for (l = objects; l != NULL; l = l->next) {
        GObject *object = l->data;
        PyObject *py_object;

        py_object = pygobject_new (object);
        if (py_object == NULL) {
            g_list_free (objects);
            Py_DECREF (py_list);
            return NULL;
        }

        PyList_Append (py_list, py_object);
        Py_DECREF (py_object);
    }

    g_list_free (objects);

    return py_list;
#else
    return NULL;
#endif /* CLUTTER_CHECK_VERSION(0, 8, 2) */
}
%%
