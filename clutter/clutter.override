/* -*- C -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"

#include "pyclutter-private.h"

#ifdef HAVE_PYCAIRO
# include <pycairo.h>
extern Pycairo_CAPI_t *Pycairo_CAPI;
#endif

/* from the cogl portion */
extern PyTypeObject PyCoglHandle_Type;

/* exceptions */
extern PyObject *PyClutterException;
extern PyObject *PyClutterWarning;

%%
include
  clutter-actor.override
  clutter-behaviour.override
  clutter-boxed.override
  clutter-color.override
  clutter-effect.override
  clutter-event.override
  clutter-model.override
  clutter-script.override

%%
modulename clutter
%%
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import pango.Context as PyPangoContext_Type
import pango.Font as PyPangoFont_Type
import pango.Layout as PyPangoLayout_Type

%%
ignore
  clutter_init_with_args
  clutter_backend_get_event
  clutter_backend_put_event
  clutter_backend_peek_event
  clutter_get_option_group
  clutter_rectangle_new_with_color
  clutter_container_add_actor
  clutter_container_add_valist
  clutter_container_remove_actor
  clutter_container_remove_valist
  clutter_threads_add_idle_full
  clutter_threads_add_idle
  clutter_threads_add_timeout_full
  clutter_threads_add_timeout
  clutter_threads_add_frame_source
  clutter_threads_add_frame_source_full
  clutter_threads_set_lock_functions
  clutter_timeline_new_for_duration
  clutter_actor_box_get_from_vertices
  clutter_stage_manager_get_default
  clutter_get_input_device_for_id
  clutter_container_child_set_property
  clutter_container_child_get_property
  clutter_container_child_set
  clutter_container_child_get
  clutter_container_class_find_child_property
  clutter_container_class_list_child_properties
%%
ignore-glob
  *_quark
  *_get_type
  _*
%%
override clutter_init noargs
static PyObject *
_wrap_clutter_init (PyObject *self, PyObject *args)
{
    PyObject *av;
    int argc, i;
    char **argv;
    
    /* initialise Clutter... */
    av = PySys_GetObject("argv");
    if (av != NULL) {
	if (!PyList_Check(av)) {
	    PyErr_Warn(PyExc_Warning, "ignoring sys.argv: it must be a list of strings");
	    av = NULL;
	} else {
	    argc = PyList_Size(av);
	    for (i = 0; i < argc; i++)
		if (!PyString_Check(PyList_GetItem(av, i))) {
		    PyErr_Warn(PyExc_Warning, "ignoring sys.argv: it must be a list of strings");
		    av = NULL;
		    break;
		}
	}
    }
    if (av != NULL) {
	argv = g_new(char *, argc);
	for (i = 0; i < argc; i++)
	    argv[i] = g_strdup(PyString_AsString(PyList_GetItem(av, i)));
    } else {
	    argc = 0;
	    argv = NULL;
    }

    if (!clutter_init (&argc, &argv)) {
	if (argv != NULL) {
	    for (i = 0; i < argc; i++)
		g_free(argv[i]);
	    g_free(argv);
	}
	PyErr_SetString(PyExc_RuntimeError, "could not open display");
	/* set the LC_NUMERIC locale back to "C", as Python < 2.4 requires
	 * that it be set that way. */
#if PY_VERSION_HEX < 0x020400F0
	setlocale(LC_NUMERIC, "C");
#endif
	return NULL;
    }
    /* set the LC_NUMERIC locale back to "C", as Python < 2.4 requires that
     * it be set that way. */
#if PY_VERSION_HEX < 0x020400F0
    setlocale(LC_NUMERIC, "C");
#endif
    if (argv != NULL) {
	PySys_SetArgv(argc, argv);
	for (i = 0; i < argc; i++)
	    g_free(argv[i]);
	g_free(argv);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override clutter_texture_get_base_size
static PyObject *
_wrap_clutter_texture_get_base_size (PyGObject *self)
{
	gint width, height;

	clutter_texture_get_base_size (CLUTTER_TEXTURE (self->obj),
				       &width,
				       &height);
	return Py_BuildValue ("(ii)", width, height);
}
%%
override clutter_container_add
static PyObject *
_wrap_clutter_container_add (PyGObject *self,
                             PyObject  *args)
{
	ClutterContainer *container;
	int i, len;

	if ((len = PyTuple_Size(args)) < 1) {
		PyErr_SetString(PyExc_TypeError,
				"requires at least one argument");
		return NULL;
	}

	container = CLUTTER_CONTAINER (self->obj);

	for (i = 0; i < len; i++) {
		PyGObject *pyactor;
		ClutterActor *actor;

		pyactor = (PyGObject *) PyTuple_GetItem (args, i);
		if (!pygobject_check (pyactor, &PyClutterActor_Type)) {
			PyErr_SetString (PyExc_TypeError,
					 "Expected a ClutterActor");
			return NULL;
		}
		
		actor = CLUTTER_ACTOR (pyactor->obj);

		clutter_container_add_actor (container, actor);
	}

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_container_remove
static PyObject *
_wrap_clutter_container_remove (PyGObject *self,
                                PyObject  *args)
{
	ClutterContainer *container;
	int i, len;

	if ((len = PyTuple_Size(args)) < 1) {
		PyErr_SetString(PyExc_TypeError,
				"requires at least one argument");
		return NULL;
	}

	container = CLUTTER_CONTAINER (self->obj);

	for (i = 0; i < len; i++) {
		PyGObject *pyactor;
		ClutterActor *actor;

		pyactor = (PyGObject *) PyTuple_GetItem (args, i);
		if (!pygobject_check (pyactor, &PyClutterActor_Type)) {
			PyErr_SetString (PyExc_TypeError,
					 "Expected a ClutterActor");
			return NULL;
		}
		
		actor = CLUTTER_ACTOR (pyactor->obj);

		clutter_container_remove_actor (container, actor);
	}

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_main noargs
static PyObject *
_wrap_clutter_main (PyObject *self)
{
	pyg_begin_allow_threads;
	clutter_main ();
	pyg_end_allow_threads;

	if (PyErr_Occurred ())
		return NULL;
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_main_quit
static PyObject *
_wrap_clutter_main_quit (PyObject *self, PyObject *args)
{
	/* sanity check to make sure we are in a main loop */
	if (clutter_main_level () == 0) {
		PyErr_SetString (PyExc_RuntimeError,
				 "called outside of a mainloop");
		return NULL;
	}

	clutter_main_quit ();
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_stage_set_color kwargs
static PyObject *
_wrap_clutter_stage_set_color (PyGObject *self,
                               PyObject  *args,
                               PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterStage.set_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_stage_set_color (CLUTTER_STAGE (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_stage_get_color noargs
static PyObject *
_wrap_clutter_stage_get_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_stage_get_color (CLUTTER_STAGE (self->obj), &color);

        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);	
}
%%
override clutter_rectangle_set_color kwargs
static PyObject *
_wrap_clutter_rectangle_set_color (PyGObject *self,
                                   PyObject  *args,
                                   PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color = { 0, };

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterRectangle.set_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_rectangle_set_color (CLUTTER_RECTANGLE (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_rectangle_get_color noargs
static PyObject *
_wrap_clutter_rectangle_get_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_rectangle_get_color (CLUTTER_RECTANGLE (self->obj), &color);

        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override clutter_rectangle_set_border_color kwargs
static PyObject *
_wrap_clutter_rectangle_set_border_color (PyGObject *self,
                                          PyObject  *args,
                                          PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterRectangle.set_border_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_rectangle_set_border_color (CLUTTER_RECTANGLE (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_rectangle_get_border_color noargs
static PyObject *
_wrap_clutter_rectangle_get_border_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_rectangle_get_border_color (CLUTTER_RECTANGLE (self->obj),
                                            &color);
	
        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override clutter_label_set_color kwargs
static PyObject *
_wrap_clutter_label_set_color (PyGObject *self,
                               PyObject  *args,
                               PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterLabel.set_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_label_set_color (CLUTTER_LABEL (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_label_get_color noargs
static PyObject *
_wrap_clutter_label_get_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_label_get_color (CLUTTER_LABEL (self->obj), &color);
	
        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override clutter_container_foreach kwargs
static void
pyclutter_container_foreach (ClutterActor *actor,
                             gpointer      data)
{
        PyClutterCallback *pycb = data;
        PyGILState_STATE state;
        PyObject *py_actor;
        PyObject *retobj;

        state = pyg_gil_state_ensure ();

        py_actor = pygobject_new ((GObject *) actor);
        retobj = pyclutter_callback_invoke (pycb, py_actor);
        if (retobj == NULL)
                PyErr_Print ();

        Py_XDECREF (retobj);

        pyg_gil_state_release (state);
}
static PyObject *
_wrap_clutter_container_foreach (PyGObject *self,
                                 PyObject  *args,
                                 PyObject  *kwargs)
{
        static char *kwlist[] = { "func", "data", NULL };
        PyObject *py_func, *py_data = NULL;
        ClutterContainer *container;
        PyClutterCallback *pycb;
        GType param_types[] = { CLUTTER_TYPE_ACTOR, };

        if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                         "O|O:clutter.Container.foreach",
                                         kwlist,
                                         &py_func, &py_data)) {
                return NULL;
        }

        if (!PyCallable_Check (py_func)) {
                PyErr_SetString (PyExc_TypeError, "func must be callable");
                return NULL;
        }

        pycb = pyclutter_callback_new (py_func, py_data,
                                       1, param_types);

        container = CLUTTER_CONTAINER (self->obj);
        clutter_container_foreach (container, pyclutter_container_foreach, pycb);

        pyclutter_callback_free (pycb);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_container_get_children noargs
static PyObject *
_wrap_clutter_container_get_children (PyGObject *self)
{
        GList *children, *l;
        PyObject *py_list;

        children = clutter_container_get_children (CLUTTER_CONTAINER (self->obj));

        if ((py_list = PyList_New (0)) == NULL) {
                g_list_free (children);
                return NULL;
        }

        for (l = children; l != NULL; l = l->next) {
                ClutterActor *actor = l->data;
                PyObject *py_actor;

                py_actor = pygobject_new ((GObject *) actor);
                if (!py_actor) {
                        g_list_free (children);
                        Py_DECREF (py_list);
                        return NULL;
                }

                PyList_Append (py_list, py_actor);
                Py_DECREF (py_actor);
        }

        g_list_free (children);

        return py_list;
}
%%
override clutter_stage_get_fog noargs
static PyObject *
_wrap_clutter_stage_get_fog (PyGObject *self)
{
        gdouble density, z_near, z_far;

        clutter_stage_get_fog (CLUTTER_STAGE (self->obj),
                               &density,
                               &z_near,
                               &z_far);

        return Py_BuildValue ("(ddd)", density, z_near, z_far);
}
%%
override clutter_stage_get_perspective noargs
static PyObject *
_wrap_clutter_stage_get_perspective (PyGObject *self)
{
        gfloat fovy, aspect, z_near, z_far;

        clutter_stage_get_perspective (CLUTTER_STAGE (self->obj),
                                       &fovy, &aspect, &z_near, &z_far);

        return Py_BuildValue ("(ffff)", fovy, aspect, z_near, z_far);
}
%%
override clutter_threads_init noargs
static PyObject *
_wrap_clutter_threads_init (PyObject *self)
{
        if (pyg_enable_threads ())
                return NULL;
        
        clutter_threads_init ();

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_threads_enter noargs
static PyObject *
_wrap_clutter_threads_enter (PyObject *self)
{
        /* must allow threads while acquiring lock, or no other python
         * code will execute while we wait
         */
        pyg_begin_allow_threads;
        clutter_threads_enter ();
        pyg_end_allow_threads;

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_timeline_get_delta noargs
static PyObject *
_wrap_clutter_timeline_get_delta (PyGObject *self)
{
  guint frames, msecs;

  frames = clutter_timeline_get_delta (CLUTTER_TIMELINE (self->obj), &msecs);

  return Py_BuildValue ("(ii)", frames, msecs);
}
%%
override clutter_score_list_timelines noargs
static PyObject *
_wrap_clutter_score_list_timelines (PyGObject *self)
{
  GSList *timelines, *l;
  PyObject *py_list;

  timelines = clutter_score_list_timelines (CLUTTER_SCORE (self->obj));

  if ((py_list = PyList_New (0)) == NULL) {
    g_slist_free (timelines);
    return NULL;
  }

  for (l = timelines; l != NULL; l = l->next) {
    ClutterTimeline *timeline = l->data;
    PyObject *py_timeline = NULL;

    py_timeline = pygobject_new ((GObject *) timeline);
    if (!py_timeline) {
      g_slist_free (timelines);
      Py_DECREF (py_list);
      return NULL;
    }

    PyList_Append (py_list, py_timeline);
    Py_DECREF (py_timeline);
  }

  g_slist_free (timelines);

  return py_list;
}
%%
override clutter_timeline_list_markers kwargs
static PyObject *
_wrap_clutter_timeline_list_markers (PyGObject *self,
                                     PyObject  *args,
                                     PyObject  *kwargs)
{
  static char *kwlist[] = { "frame_num", NULL };
  gchar **markers;
  gint frame_num = 0;
  guint i;
  gsize n_markers;
  PyObject *py_ret;

  if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                    "i:ClutterTimeline.list_markers", kwlist,
                                    &frame_num))
    {
      return NULL;
    }

  markers = clutter_timeline_list_markers (CLUTTER_TIMELINE (self->obj),
                                           frame_num,
                                           &n_markers);
  if (n_markers == 0)
    {
      Py_INCREF (Py_None);
      return Py_None;
    }

  if ((py_ret = PyList_New (0)) == NULL)
    {
      g_strfreev (markers);
      return NULL;
    }

  for (i = 0; i < n_markers; i++)
    {
      gchar *marker_name = markers[i];

      PyList_Append (py_ret, PyString_FromString (marker_name));
    }

  g_strfreev (markers);

  return py_ret;
}
%%
new-constructor CLUTTER_TYPE_STAGE_MANAGER
%%
override clutter_stage_manager_new noargs
static int
_wrap_clutter_stage_manager_new (PyGObject *self)
{
  self->obj = (GObject *) clutter_stage_manager_get_default ();
  if (!self->obj)
    {
      PyErr_SetString (PyExc_RuntimeError, "could not get the default stage manager");
      return -1;
    }

  g_object_ref (self->obj);
  pygobject_register_wrapper ((PyObject *) self);

  return 0;
}
%%
new-constructor CLUTTER_TYPE_STAGE
%%
override clutter_stage_new noargs
static int
_wrap_clutter_stage_new (PyGObject *self)
{
  self->obj = (GObject *) clutter_stage_new ();
  if (!self->obj)
    {
      PyErr_SetString (PyExc_RuntimeError, "could not create a clutter.Stage");
      return -1;
    }

  g_object_ref (self->obj);
  pygobject_register_wrapper ((PyObject *) self);

  return 0;
}
%%
override clutter_score_append kwargs
static PyObject *
_wrap_clutter_score_append (PyGObject *self,
                            PyObject  *args,
                            PyObject  *kwargs)
{
        static char *kwlist[] = { "timeline", "parent", NULL };
        PyObject *py_timeline, *py_parent = NULL;
        ClutterTimeline *timeline, *parent;
        ClutterScore *score;
        guint ret;

        if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                         "O|O:clutter.Score.append",
                                         kwlist,
                                         &py_timeline, &py_parent)) {
                return NULL;
        }

        if (!py_timeline || py_timeline == Py_None ||
            !pygobject_check (py_timeline, &PyClutterTimeline_Type)) {
                PyErr_SetString (PyExc_TypeError, "timeline must be a clutter.Timeline");
                return NULL;
        }
        else
                timeline = CLUTTER_TIMELINE (pygobject_get (py_timeline));

        if (!py_parent || py_parent == Py_None)
                parent = NULL;
        else if (pygobject_check (py_parent, &PyClutterTimeline_Type))
                parent = CLUTTER_TIMELINE (pygobject_get (py_parent));
        else {
                PyErr_SetString (PyExc_TypeError, "parent must either be a clutter.Timeline or None");
                return NULL;
        }

        score = CLUTTER_SCORE (self->obj);
        ret = clutter_score_append (score, parent, timeline);
        g_assert (timeline == clutter_score_get_timeline (score, ret));

        return PyLong_FromUnsignedLong (ret);
}
%%
override clutter_stage_set_key_focus kwargs
static PyObject *
_wrap_clutter_stage_set_key_focus (PyGObject *self,
                                   PyObject  *args,
                                   PyObject  *kwargs)
{
  static char *kwlist[] = { "actor", NULL };
  PyObject *py_actor = NULL;

  if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                    "|O:clutter.Stage.set_key_focus", kwlist,
                                    &py_actor))
    return NULL;

  if (!py_actor || py_actor == Py_None)
    clutter_stage_set_key_focus (CLUTTER_STAGE (self->obj), NULL);
  else if (pygobject_check (py_actor, &PyClutterActor_Type)) {
    ClutterActor *actor = CLUTTER_ACTOR (pygobject_get (py_actor));

    clutter_stage_set_key_focus(CLUTTER_STAGE(self->obj), actor);
  }
  else {
    PyErr_SetString (PyExc_TypeError, "first argument must either be None "
                                      "or a clutter.Actor");
    return NULL;
  }

  Py_INCREF (Py_None);
  return Py_None;
}
%%
override clutter_backend_get_font_options noargs
static PyObject *
_wrap_clutter_backend_get_font_options (PyGObject *self)
{
#ifdef HAVE_PYCAIRO
  const cairo_font_options_t *options;

  options = clutter_backend_get_font_options (CLUTTER_BACKEND (self->obj));
  if (!options)
    {
      Py_INCREF (Py_None);
      return Py_None;
    }

  return PycairoFontOptions_FromFontOptions (cairo_font_options_copy (options));
#else
  Py_INCREF (Py_None);
  return Py_None;
#endif
}
%%
override clutter_backend_set_font_options kwargs
static PyObject *
_wrap_clutter_backend_set_font_options (PyGObject *self,
                                        PyObject  *args,
                                        PyObject  *kwargs)
{
#ifdef HAVE_PYCAIRO
  static char *kwlist[] = { "options", NULL };
  PyGObject *py_options;
  cairo_font_options_t *options;

  if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                    "O:clutter.Backend.set_font_options",
                                    kwlist, &py_options))
    return NULL;

  if ((PyObject*) py_options == Py_None)
    options = NULL;
  else if (pygobject_check(py_options, &PycairoFontOptions_Type))
    options = ((PycairoFontOptions *) py_options)->font_options;
  else
    {
      PyErr_SetString(PyExc_TypeError,
                      "options must be a cairo.FontOptions or None");
      return NULL;
    }

  clutter_backend_set_font_options (CLUTTER_BACKEND (self->obj), options);
#endif

  Py_INCREF(Py_None);
  return Py_None;
}
%%
override clutter_texture_get_cogl_texture noargs
static PyObject *
_wrap_clutter_texture_get_cogl_texture (PyGObject *self)
{
  CoglHandle hnd = COGL_INVALID_HANDLE;

  hnd = clutter_texture_get_cogl_texture (CLUTTER_TEXTURE (self->obj));
  if (hnd == COGL_INVALID_HANDLE)
    {
      Py_INCREF (Py_None);
      return Py_None;
    }
  else
    return pyg_boxed_new (PYCOGL_TYPE_HANDLE, hnd, TRUE, TRUE);
}
%%
override clutter_texture_set_cogl_texture kwargs
static PyObject *
_wrap_clutter_texture_set_cogl_texture (PyGObject *self,
                                        PyObject  *args,
                                        PyObject  *kwargs)
{
  static char *kwlist[] = { "handle", NULL };
  PyObject *py_handle = NULL;
  CoglHandle handle = COGL_INVALID_HANDLE;

  if (!PyArg_ParseTupleAndKeywords(args, kwargs,"O:ClutterTexture.set_cogl_texture", kwlist, &py_handle))
    return NULL;

  if (pyg_boxed_check (py_handle, PYCOGL_TYPE_HANDLE))
    handle = pyg_boxed_get(py_handle, CoglHandle);
  else
    {
      PyErr_SetString (PyExc_TypeError, "handle should be a cogl.Handle");
      return NULL;
    }
    
  clutter_texture_set_cogl_texture (CLUTTER_TEXTURE(self->obj), handle);
    
  Py_INCREF(Py_None);
  return Py_None;
}
