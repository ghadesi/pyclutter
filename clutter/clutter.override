/* -*- C -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include <clutter/clutter-keysyms.h>
#include <clutter/clutter-event.h>
#include <clutter/clutter-media.h>
#include <clutter/clutter-main.h>
#include <clutter/clutter-timeline.h>
#include <clutter/clutter-stage.h>
#include <clutter/clutter-color.h>
#include <clutter/clutter-actor.h>
#include <clutter/clutter-rectangle.h>
#include <clutter/clutter-group.h>
#include <clutter/clutter-texture.h>
#include <clutter/clutter-video-texture.h>
#include <clutter/clutter-clone-texture.h>
#include <clutter/clutter-label.h>
#include <clutter/clutter-util.h>
#include <clutter/clutter-enum-types.h>
%%
modulename clutter
%%
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
%%
ignore
  clutter_video_texture_error_quark
  clutter_video_texture_get_metadata
  clutter_group_add_many_valist
  clutter_stage_get_xwindow
  clutter_init
  clutter_xdisplay
  clutter_root_xwindow
  clutter_gl_context
%%
ignore-glob
  *_get_type
  _*
%%
override clutter_geometry_new kwargs
static int
_wrap_clutter_geometry_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x", "y", "width", "height", NULL };
	ClutterGeometry geom = { 0, 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iiii:ClutterGeometry.__init__",
					 kwlist,
					 &(geom.x), &(geom.y),
					 &(geom.width), &(geom.height)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_GEOMETRY, &geom);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_GEOMETRY;
	
	return 0;
}
%%
override-slot ClutterGeometry.tp_as_sequence
static int
_wrap_clutter_geometry_length (PyGBoxed *self)
{
	return 4;
}
static PyObject *
_wrap_clutter_geometry_getitem(PyGBoxed *self, int pos)
{
	ClutterGeometry *geom;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	geom = pyg_boxed_get (self, ClutterGeometry);
	switch (pos) {
		case 0: return PyInt_FromLong (geom->x);
		case 1: return PyInt_FromLong (geom->y);
		case 2: return PyInt_FromLong (geom->width);
		case 3: return PyInt_FromLong (geom->height);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_geometry_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterGeometry *geom;
	gint val;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	geom = pyg_boxed_get (self, ClutterGeometry);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: geom->x      = val; break;
		case 1: geom->y      = val; break;
		case 2: geom->width  = val; break;
		case 3: geom->height = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_geometry_tp_as_sequence = {
	(inquiry) _wrap_clutter_geometry_length,
	(binaryfunc) 0,
	(intargfunc) 0,
	(intargfunc) _wrap_clutter_geometry_getitem,
	(intintargfunc) 0,
	(intobjargproc) _wrap_clutter_geometry_setitem,
	(intintobjargproc) 0
};
%%
override-attr ClutterGeometry.x
static int
_wrap_clutter_geometry__set_x (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterGeometry)->x = val;

	return 0;
}
%%
override-attr ClutterGeometry.y
static int
_wrap_clutter_geometry__set_y (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterGeometry)->y = val;

	return 0;
}
%%
override-attr ClutterGeometry.width
static int
_wrap_clutter_geometry__set_width (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
        	return -1;
	
	pyg_boxed_get(self, ClutterGeometry)->width = val;
	
	return 0;
}
%%
override-attr ClutterGeometry.height
static int
_wrap_clutter_geometry__set_height (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	pyg_boxed_get (self, ClutterGeometry)->height = val;

	return 0;
}
%%
override clutter_actor_box_new kwargs
static int
_wrap_clutter_actor_box_new (PyGBoxed *self, PyObject *args, PyObject *kwargs)
{
	static char *kwlist[] = { "x1", "y1", "x2", "y2", NULL };
	ClutterActorBox box = { 0, 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iiii:ClutterActorBox.__init__",
					 kwlist,
					 &(box.x1), &(box.y1),
					 &(box.x2), &(box.y2)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_ACTOR_BOX, &box);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_ACTOR_BOX;
	
	return 0;
}
%%
override-slot ClutterActorBox.tp_as_sequence
static int
_wrap_clutter_actor_box_length (PyGBoxed *self)
{
	return 4;
}
static PyObject *
_wrap_clutter_actor_box_getitem(PyGBoxed *self, int pos)
{
	ClutterActorBox *box;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return NULL;
	}

	box = pyg_boxed_get (self, ClutterActorBox);
	switch (pos) {
		case 0: return PyInt_FromLong (box->x1);
		case 1: return PyInt_FromLong (box->y1);
		case 2: return PyInt_FromLong (box->x2);
		case 3: return PyInt_FromLong (box->y2);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_actor_box_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterActorBox *box;
	gint val;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString(PyExc_IndexError, "index out of range");
		
		return -1;
	}

	box = pyg_boxed_get (self, ClutterActorBox);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch(pos) {
		case 0: box->x1 = val; break;
		case 1: box->y1 = val; break;
		case 2: box->x2 = val; break;
		case 3: box->y2 = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_actor_box_tp_as_sequence = {
	(inquiry) _wrap_clutter_actor_box_length,
	(binaryfunc) 0,
	(intargfunc) 0,
	(intargfunc) _wrap_clutter_actor_box_getitem,
	(intintargfunc) 0,
	(intobjargproc) _wrap_clutter_actor_box_setitem,
	(intintobjargproc) 0
};
%%
override-attr ClutterActorBox.x1
static int
_wrap_clutter_actor_box__set_x1 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterActorBox)->x1 = val;

	return 0;
}
%%
override-attr ClutterActorBox.y1
static int
_wrap_clutter_actor_box__set_y1 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterActorBox)->y1 = val;

	return 0;
}
%%
override-attr ClutterActorBox.x2
static int
_wrap_clutter_actor_box__set_x2 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
        	return -1;
	
	pyg_boxed_get(self, ClutterActorBox)->x2 = val;
	
	return 0;
}
%%
override-attr ClutterActorBox.y2
static int
_wrap_clutter_actor_box__set_y2 (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	pyg_boxed_get (self, ClutterActorBox)->y2 = val;

	return 0;
}
%%
override clutter_actor_get_coords
static PyObject *
_wrap_clutter_actor_get_coords (PyGObject *self)
{
	gint x1, y1;
	gint x2, y2;

	clutter_actor_get_coords (CLUTTER_ACTOR (self->obj),
				    &x1, &y1,
				    &x2, &y2);
	return Py_BuildValue("(iiii)", x1, y1, x2, y2);
}
%%
override clutter_actor_get_abs_position
static PyObject *
_wrap_clutter_actor_get_abs_position (PyGObject *self)
{
	gint pos_x, pos_y;

	clutter_actor_get_abs_position (CLUTTER_ACTOR (self->obj),
					  &pos_x,
					  &pos_y);
	return Py_BuildValue("(ii)", pos_x, pos_y);
}
%%
override clutter_texture_get_base_size
static PyObject *
_wrap_clutter_texture_get_base_size (PyGObject *self)
{
	gint width, height;

	clutter_texture_get_base_size (CLUTTER_TEXTURE (self->obj),
				       &width,
				       &height);
	return Py_BuildValue ("(ii)", width, height);
}
%%
override clutter_texture_get_n_tiles
static PyObject *
_wrap_clutter_texture_get_n_tiles (PyGObject *self)
{
	gint n_x_tiles, n_y_tiles;

	clutter_texture_get_n_tiles (CLUTTER_TEXTURE (self->obj),
				     &n_x_tiles,
				     &n_y_tiles);
	return Py_BuildValue ("(ii)", n_x_tiles, n_y_tiles);
}
%%
override clutter_texture_get_x_tile_detail kwargs
static PyObject *
_wrap_clutter_texture_get_x_tile_detail (PyGObject *self,
                                         PyObject  *args,
					 PyObject  *kwargs)
{
	static char *kwlist[] = { "x_index", NULL };
	gint x_index;
	gint pos, size, waste;

	if (!PyArg_ParseTupleAndKeywords (args, kwargs,
					  "i:ClutterTexture.get_x_tile_detail",
					  kwlist, &x_index))
		return NULL;
	
	clutter_texture_get_x_tile_detail (CLUTTER_TEXTURE (self->obj),
					   x_index,
					   &pos, &size, &waste);
	return Py_BuildValue ("(iii)", pos, size, waste);
}
%%
override clutter_texture_get_y_tile_detail kwargs
static PyObject *
_wrap_clutter_texture_get_y_tile_detail (PyGObject *self,
                                         PyObject  *args,
					 PyObject  *kwargs)
{
	static char *kwlist[] = { "y_index", NULL };
	gint y_index;
	gint pos, size, waste;

	if (!PyArg_ParseTupleAndKeywords (args, kwargs,
					  "i:ClutterTexture.get_y_tile_detail",
					  kwlist, &y_index))
		return NULL;
	
	clutter_texture_get_y_tile_detail (CLUTTER_TEXTURE (self->obj),
					   y_index,
					   &pos, &size, &waste);
	return Py_BuildValue ("(iii)", pos, size, waste);
}
%%
override clutter_group_add_many
static PyObject *
_wrap_clutter_group_add_many (PyGObject *self,
			      PyObject  *args)
{
	ClutterGroup *group;
	int i, len;

	if ((len = PyTuple_Size(args)) < 1) {
		PyErr_SetString(PyExc_TypeError,
				"requires at least one argument");
		return NULL;
	}

	group = CLUTTER_GROUP (self->obj);

	for (i = 0; i < len; i++) {
		PyGObject *pyactor;
		ClutterActor *actor;

		pyactor = (PyGObject *) PyTuple_GetItem (args, i);
		if (!pygobject_check (pyactor, &PyClutterActor_Type)) {
			PyErr_SetString (PyExc_TypeError,
					 "Expected a ClutterActor");
			return NULL;
		}
		
		actor = CLUTTER_ACTOR (pyactor->obj);

		clutter_group_add (group, actor);
	}

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_main noargs
static PyObject *
_wrap_clutter_main (PyObject *self)
{
	pyg_begin_allow_threads;
	clutter_main ();
	pyg_end_allow_threads;

	if (PyErr_Occurred ())
		return NULL;
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_main_quit
static PyObject *
_wrap_clutter_main_quit (PyObject *self, PyObject *args)
{
	/* sanity check to make sure we are in a main loop */
	if (clutter_main_level () == 0) {
		PyErr_SetString (PyExc_RuntimeError,
				 "called outside of a mainloop");
		return NULL;
	}

	clutter_main_quit ();
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_threads_enter noargs
static PyObject *
_wrap_clutter_threads_enter (PyObject *self)
{
	/* must allow threads while acquiring lock, or no other python
         * code will execute while we wait! */
	pyg_begin_allow_threads;
	clutter_threads_enter ();
	pyg_end_allow_threads;

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override clutter_color_new kwargs
static int
_wrap_clutter_color_new (PyGBoxed *self,
			 PyObject *args,
			 PyObject *kwargs)
{
	static char *kwlist[] = { "red", "green", "blue", "alpha", NULL };
	ClutterColor color = { 0, 0, 0, 0 };

	if (!PyArg_ParseTupleAndKeywords(args, kwargs,
					 "|iiii:ClutterColor.__init__",
					 kwlist,
					 &(color.red),
					 &(color.green),
					 &(color.blue),
					 &(color.alpha)))
		return -1;
	
	self->boxed = g_boxed_copy (CLUTTER_TYPE_COLOR, &color);
	self->free_on_dealloc = TRUE;
	self->gtype = CLUTTER_TYPE_COLOR;
	
	return 0;
}
%%
override-slot ClutterColor.tp_as_sequence
static int
_wrap_clutter_color_length (PyGBoxed *self)
{
	return 4;
}
static PyObject *
_wrap_clutter_color_getitem (PyGBoxed *self, int pos)
{
	ClutterColor *color;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString (PyExc_IndexError, "index out of range");
		return NULL;
	}

	color = pyg_boxed_get (self, ClutterColor);
	switch (pos) {
		case 0: return PyInt_FromLong (color->red);
		case 1: return PyInt_FromLong (color->green);
		case 2: return PyInt_FromLong (color->blue);
		case 3: return PyInt_FromLong (color->alpha);
		default:
			g_assert_not_reached();
			return NULL;
	}
}
static int
_wrap_clutter_color_setitem (PyGBoxed *self, int pos, PyObject *value)
{
	ClutterColor *color;
	gint val;

	if (pos < 0)
		pos += 4;
	
	if (pos < 0 || pos >= 4) {
		PyErr_SetString (PyExc_IndexError, "index out of range");
		return -1;
	}

	color = pyg_boxed_get (self, ClutterColor);
	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	switch (pos) {
		case 0: color->red   = val; break;
		case 1: color->green = val; break;
		case 2: color->blue  = val; break;
		case 3: color->alpha = val; break;
		default:
			g_assert_not_reached();
			return -1;
	}

	return 0;
}
static PySequenceMethods _wrap_clutter_color_tp_as_sequence = {
	(inquiry) _wrap_clutter_color_length,
	(binaryfunc) 0,
	(intargfunc) 0,
	(intargfunc) _wrap_clutter_color_getitem,
	(intintargfunc) 0,
	(intobjargproc) _wrap_clutter_color_setitem,
	(intintobjargproc) 0
};
%%
override-attr ClutterColor.red
static int
_wrap_clutter_color__set_red (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterColor)->red = val;

	return 0;
}
%%
override-attr ClutterColor.green
static int
_wrap_clutter_color__set_green (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;

	pyg_boxed_get (self, ClutterColor)->green = val;

	return 0;
}
%%
override-attr ClutterColor.blue
static int
_wrap_clutter_color__set_blue (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
        	return -1;
	
	pyg_boxed_get(self, ClutterColor)->blue = val;
	
	return 0;
}
%%
override-attr ClutterColor.alpha
static int
_wrap_clutter_color__set_alpha (PyGBoxed *self, PyObject *value, void *closure)
{
	gint val;

	val = PyInt_AsLong (value);
	if (PyErr_Occurred ())
		return -1;
	
	pyg_boxed_get (self, ClutterColor)->alpha = val;

	return 0;
}
%%
override clutter_stage_set_color
static PyObject *
_wrap_clutter_stage_set_color (PyGObject *self,
			       PyObject  *args)
{
	ClutterColor color;
	int len, i;

	if ((len = PyTuple_Size (args)) != 4) {
		PyErr_SetString (PyExc_TypeError,
				 "requires a tuple of 4 integers: (r, g, b, a)");
		return NULL;
	}

	for (i = 0; i < len; i++) {
		PyObject *comp = PyTuple_GetItem (args, i);
		
		if (!PyInt_Check (comp)) {
			PyErr_SetString (PyExc_TypeError,
					 "component is not an integer");
			return NULL;
		}
		
		switch (i) {
			case 0: color.red   = (guint8) PyInt_AsLong (comp); break;
			case 1: color.green = (guint8) PyInt_AsLong (comp); break;
			case 2: color.blue  = (guint8) PyInt_AsLong (comp); break;
			case 3: color.alpha = (guint8) PyInt_AsLong (comp); break;
			default:
				g_assert_not_reached ();
				break;
		}
	}
	
	clutter_stage_set_color (CLUTTER_STAGE (self->obj), &color);

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_stage_get_color
static PyObject *
_wrap_clutter_stage_get_color (PyGObject *self,
			       PyObject  *args)
{
	ClutterColor color;

	clutter_stage_get_color (CLUTTER_STAGE (self->obj), &color);
	
	return Py_BuildValue ("(iiii)", color.red,
					color.green,
					color.blue,
					color.alpha);
}
%%
override clutter_color_to_hls
static PyObject *
_wrap_clutter_color_to_hls (PyObject *self,
			    PyObject *args)
{
	ClutterColor color;
	guint8 h, l, s;
	int i;

	if (PyTuple_Size (args) != 4) {
		PyErr_SetString (PyExc_TypeError,
				 "requires a tuple of 4 integers: (r, g, b, a)");
		return NULL;
	}

	for (i = 0; i < 4; i++) {
		PyObject *comp = PyTuple_GetItem (args, i);

		if (!PyInt_Check (comp)) {
			PyErr_SetString (PyExc_TypeError,
					 "component is not an integer");
			return NULL;
		}

		switch (i) {
			case 0: color.red   = (guint8) PyInt_AsLong (comp); break;
			case 1: color.green = (guint8) PyInt_AsLong (comp); break;
			case 2: color.blue  = (guint8) PyInt_AsLong (comp); break;
			case 3: color.alpha = (guint8) PyInt_AsLong (comp); break;
			default:
				g_assert_not_reached ();
				break;
		}
	}

	clutter_color_to_hls (&color, &h, &l, &s);

	return Py_BuildValue ("(iii)", (int) h, (int) l, (int) s);
}
%%
override clutter_color_from_hls
static PyObject *
_wrap_clutter_color_from_hls (PyObject *self,
			      PyObject *args)
{
	ClutterColor color;
	guint8 h, l, s;
	int i;

	if (PyTuple_Size (args) != 3) {
		PyErr_SetString (PyExc_TypeError,
				 "requires a tuple of 3 integers: (h, l, s)");
		return NULL;
	}

	h = l = s = 0;
	for (i = 0; i < 3; i++) {
		PyObject *comp = PyTuple_GetItem (args, i);

		if (!PyInt_Check (comp)) {
			PyErr_SetString (PyExc_TypeError,
					 "component is not an integer");
			return NULL;
		}

		switch (i) {
			case 0: h = (guint8) PyInt_AsLong (comp); break;
			case 1: l = (guint8) PyInt_AsLong (comp); break;
			case 2: s = (guint8) PyInt_AsLong (comp); break;
			default:
				g_assert_not_reached ();
				break;
		}
	}

	clutter_color_from_hls (&color, h, l, s);

	return Py_BuildValue ("(iiii)",
			      (int) color.red,
			      (int) color.green,
			      (int) color.blue,
			      (int) color.alpha);
}
%%
override clutter_color_to_pixel
static PyObject *
_wrap_clutter_color_to_pixel (PyObject *self,
			      PyObject *args)
{
	ClutterColor color;
	guint32 pixel;
	int i;

	if (PyTuple_Size (args) != 4) {
		PyErr_SetString (PyExc_TypeError,
				 "requires a tuple of 4 integers: (r, g, b, a)");
		return NULL;
	}

	for (i = 0; i < 4; i++) {
		PyObject *comp = PyTuple_GetItem (args, i);

		if (!PyInt_Check (comp)) {
			PyErr_SetString (PyExc_TypeError,
					 "component is not an integer");
			return NULL;
		}

		switch (i) {
			case 0: color.red   = (guint8) PyInt_AsLong (comp); break;
			case 1: color.green = (guint8) PyInt_AsLong (comp); break;
			case 2: color.blue  = (guint8) PyInt_AsLong (comp); break;
			case 3: color.alpha = (guint8) PyInt_AsLong (comp); break;
			default:
				g_assert_not_reached ();
				break;
		}
	}

	pixel = clutter_color_to_pixel (&color);

	return PyInt_FromLong (pixel);
}
%%
override clutter_color_from_pixel
static PyObject *
_wrap_clutter_color_from_pixel (PyObject *self,
			        PyObject *args)
{
	ClutterColor color;
	guint32 pixel;

	if (!PyInt_Check (args)) {
		PyErr_SetString (PyExc_TypeError,
				 "requires a 32 bit encoded integer");
		return NULL;
	}

	pixel = (guint32) PyInt_AsLong (args);

	clutter_color_from_pixel (&color, pixel);

	return Py_BuildValue ("(iiii)",
			      (int) color.red,
			      (int) color.green,
			      (int) color.blue,
			      (int) color.alpha);
}
%%
override clutter_label_get_text_extents
static PyObject *
_wrap_clutter_label_get_text_extents (PyGObject *self,
				      PyObject  *args)
{
	gint width, height;

	clutter_label_get_text_extents (CLUTTER_LABEL (self->obj),
					&width,
					&height);
	
	return Py_BuildValue ("(ii)", width, height);
}
%%
override clutter_rectangle_set_color
static PyObject *
_wrap_clutter_rectangle_set_color (PyGObject *self,
				   PyObject  *args)
{
	ClutterColor color;
	int len, i;

	if ((len = PyTuple_Size (args)) != 4) {
		PyErr_SetString (PyExc_TypeError,
				 "requires a tuple of 4 integers: (r, g, b, a)");
		return NULL;
	}

	for (i = 0; i < len; i++) {
		PyObject *comp = PyTuple_GetItem (args, i);
		
		if (!PyInt_Check (comp)) {
			PyErr_SetString (PyExc_TypeError,
					 "component is not an integer");
			return NULL;
		}
		
		switch (i) {
			case 0: color.red   = (guint8) PyInt_AsLong (comp); break;
			case 1: color.green = (guint8) PyInt_AsLong (comp); break;
			case 2: color.blue  = (guint8) PyInt_AsLong (comp); break;
			case 3: color.alpha = (guint8) PyInt_AsLong (comp); break;
			default:
				g_assert_not_reached ();
				break;
		}
	}
	
	clutter_rectangle_set_color (CLUTTER_RECTANGLE (self->obj), &color);

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_rectangle_get_color
static PyObject *
_wrap_clutter_rectangle_get_color (PyGObject *self,
				   PyObject  *args)
{
	ClutterColor color;

	clutter_rectangle_get_color (CLUTTER_RECTANGLE (self->obj), &color);
	
	return Py_BuildValue ("(iiii)", color.red,
					color.green,
					color.blue,
					color.alpha);
}
%%
override clutter_label_set_color
static PyObject *
_wrap_clutter_label_set_color (PyGObject *self,
			       PyObject  *args)
{
	ClutterColor color;
	int len, i;

	if ((len = PyTuple_Size (args)) != 4) {
		PyErr_SetString (PyExc_TypeError,
				 "requires a tuple of 4 integers: (r, g, b, a)");
		return NULL;
	}

	for (i = 0; i < len; i++) {
		PyObject *comp = PyTuple_GetItem (args, i);
		
		if (!PyInt_Check (comp)) {
			PyErr_SetString (PyExc_TypeError,
					 "component is not an integer");
			return NULL;
		}
		
		switch (i) {
			case 0: color.red   = (guint8) PyInt_AsLong (comp); break;
			case 1: color.green = (guint8) PyInt_AsLong (comp); break;
			case 2: color.blue  = (guint8) PyInt_AsLong (comp); break;
			case 3: color.alpha = (guint8) PyInt_AsLong (comp); break;
			default:
				g_assert_not_reached ();
				break;
		}
	}
	
	clutter_label_set_color (CLUTTER_LABEL (self->obj), &color);

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_label_get_color
static PyObject *
_wrap_clutter_label_get_color (PyGObject *self,
			       PyObject  *args)
{
	ClutterColor color;

	clutter_label_get_color (CLUTTER_LABEL (self->obj), &color);
	
	return Py_BuildValue ("(iiii)", color.red,
					color.green,
					color.blue,
					color.alpha);
}
%%
override-slot ClutterEvent.tp_setattr
#define CHECK_VALUE_IS_INT(a,v) \
	G_STMT_START{ if (!PyInt_Check ((v))) { \
		PyErr_Format (PyExc_TypeError, "%s must be an int", (a)); \
		return -1; \
	} }G_STMT_END
static int
_wrap_clutter_event_tp_setattr (PyObject *self,
				char     *attr,
				PyObject *value)
{
	ClutterEvent *event;

	if (value == NULL) {
		PyErr_SetString (PyExc_TypeError, "can't delete attributes");
		return -1;
	}

	event = pyg_boxed_get (self, ClutterEvent);

	/* common members */
	if (attr[0] == 't' && !strcmp (attr, "type")) {
		PyErr_SetString (PyExc_AttributeError, "type is not writable");
		return -1;
	}

	switch (event->type) {
		case CLUTTER_NOTHING:
			break;
		case CLUTTER_MOTION:	/* ClutterMotionEvent 	motion */
			if (!strcmp (attr, "time")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->motion.time = PyInt_AsLong (value);
				return 0;
			}
			else if (attr[0] == 'x' && attr[1] == '\0') {
				CHECK_VALUE_IS_INT (attr, value);
				event->motion.x = PyInt_AsLong (value);
				return 0;
			}
			else if (attr[0] == 'y' && attr[1] == '\0') {
				CHECK_VALUE_IS_INT (attr, value);
				event->motion.y = PyInt_AsLong (value);
				return 0;
			}
			else if (!strcmp (attr, "modifier_state")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->motion.modifier_state = PyInt_AsLong (value);
				return 0;
			}
			break;
		case CLUTTER_BUTTON_PRESS:	/* ClutterButtonEvent	button */
		case CLUTTER_2BUTTON_PRESS:
		case CLUTTER_BUTTON_RELEASE:
			if (!strcmp (attr, "time")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->button.time = PyInt_AsLong (value);
				return 0;
			}
			else if (attr[0] == 'x' && attr[1] == '\0') {
				CHECK_VALUE_IS_INT (attr, value);
				event->button.x = PyInt_AsLong (value);
				return 0;
			}
			else if (attr[0] == 'y' && attr[1] == '\0') {
				CHECK_VALUE_IS_INT (attr, value);
				event->button.y = PyInt_AsLong (value);
				return 0;
			}
			else if (!strcmp (attr, "modifier_state")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->button.modifier_state = PyInt_AsLong (value);
				return 0;
			}
			else if (!strcmp (attr, "button")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->button.button = PyInt_AsLong (value);
				return 0;
			}
			break;
		case CLUTTER_KEY_PRESS: /* ClutterKeyEvent:	key */
		case CLUTTER_KEY_RELEASE:
			if (!strcmp (attr, "time")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->key.time = PyInt_AsLong (value);
				return 0;
			}
			else if (!strcmp (attr, "modifier_state")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->key.modifier_state = PyInt_AsLong (value);
				return 0;
			}
			else if (!strcmp (attr, "keyval")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->key.keyval = PyInt_AsLong (value);
				return 0;
			}
			else if (!strcmp (attr, "hardware_keycode")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->key.hardware_keycode = PyInt_AsLong (value);
				return 0;
			}
			break;
		default:
			break;
	}

	PyErr_SetString (PyExc_AttributeError, "could not write attribute");
	return -1;
}
#undef CHECK_VALUE_IS_INT
%%
override-slot ClutterEvent.tp_getattr
PyObject *
_wrap_clutter_event_tp_getattr (PyObject *self,
				char     *attr)
{
	ClutterEvent *event = pyg_boxed_get (self, ClutterEvent);

	switch (event->type) {
		case CLUTTER_NOTHING:
			break;
		case CLUTTER_MOTION: /* ClutterMotionEvent	motion */
			if (!strcmp (attr, "__members__"))
				return Py_BuildValue ("[sssss]",
						      "type",
						      "time",
						      "x", "y",
						      "modifier_state");
			if (!strcmp (attr, "time"))
				return PyInt_FromLong (event->motion.time);
			if (!strcmp (attr, "x"))
				return PyInt_FromLong (event->motion.x);
			if (!strcmp (attr, "y"))
				return PyInt_FromLong (event->motion.y);
			if (!strcmp (attr, "motifier_state"))
				return PyInt_FromLong (event->motion.modifier_state);
			break;
		case CLUTTER_BUTTON_PRESS:
		case CLUTTER_2BUTTON_PRESS:
		case CLUTTER_BUTTON_RELEASE:
			if (!strcmp (attr, "__members__"))
				return Py_BuildValue ("[ssssss]",
						      "type",
						      "time",
						      "x", "y",
						      "modifier_state",
						      "button");
			if (!strcmp (attr, "time"))
				return PyInt_FromLong (event->button.time);
			if (!strcmp (attr, "x"))
				return PyInt_FromLong (event->button.x);
			if (!strcmp (attr, "y"))
				return PyInt_FromLong (event->button.y);
			if (!strcmp (attr, "motifier_state"))
				return PyInt_FromLong (event->button.modifier_state);
			if (!strcmp (attr, "button"))
				return PyInt_FromLong (event->button.button);
			break;
		case CLUTTER_KEY_PRESS:
		case CLUTTER_KEY_RELEASE:
			if (!strcmp (attr, "__members__"))
				return Py_BuildValue ("[sssss]",
						      "type",
						      "time",
						      "modifier_state",
						      "keyval",
						      "hardware_keycode");
			if (!strcmp (attr, "time"))
				return PyInt_FromLong (event->key.time);
			if (!strcmp (attr, "motifier_state"))
				return PyInt_FromLong (event->key.modifier_state);
			if (!strcmp (attr, "keyval"))
				return PyInt_FromLong (event->key.keyval);
			if (!strcmp (attr, "hardware_keycode"))
				return PyInt_FromLong (event->key.hardware_keycode);
			break;
		default:
			break;
	}

	if (!strcmp (attr, "type"))
		return pyg_enum_from_gtype (CLUTTER_TYPE_EVENT_TYPE, event->type);
	
	return Py_FindMethod ((PyMethodDef *) _PyClutterEvent_methods, self, attr);
}
%%
