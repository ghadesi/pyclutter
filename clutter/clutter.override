/* -*- C -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include "pyclutter.h"

%%
include
  clutter-actor.override
  clutter-behaviour.override
  clutter-boxed.override
  clutter-color.override
  clutter-effect.override
  clutter-event.override
  clutter-model.override
  clutter-script.override

%%
modulename clutter
%%
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import pango.Context as PyPangoContext_Type
import pango.Font as PyPangoFont_Type
import pango.Layout as PyPangoLayout_Type

%%
ignore
  clutter_init_with_args
  clutter_backend_get_event
  clutter_backend_put_event
  clutter_backend_peek_event
  clutter_get_option_group
  clutter_rectangle_new_with_color
  clutter_container_add_actor
  clutter_container_add_valist
  clutter_container_remove_actor
  clutter_container_remove_valist
  clutter_threads_add_idle_full
  clutter_threads_add_idle
  clutter_threads_add_timeout_full
  clutter_threads_add_timeout
  clutter_threads_set_lock_functions
  clutter_texture_new_from_pixbuf
  clutter_timeline_new_for_duration

%%
ignore-glob
  *_quark
  *_get_type
  _*

%%
override clutter_init noargs
static PyObject *
_wrap_clutter_init (PyObject *self, PyObject *args)
{
    PyObject *av;
    int argc, i;
    char **argv;
    
    /* initialise Clutter... */
    av = PySys_GetObject("argv");
    if (av != NULL) {
	if (!PyList_Check(av)) {
	    PyErr_Warn(PyExc_Warning, "ignoring sys.argv: it must be a list of strings");
	    av = NULL;
	} else {
	    argc = PyList_Size(av);
	    for (i = 0; i < argc; i++)
		if (!PyString_Check(PyList_GetItem(av, i))) {
		    PyErr_Warn(PyExc_Warning, "ignoring sys.argv: it must be a list of strings");
		    av = NULL;
		    break;
		}
	}
    }
    if (av != NULL) {
	argv = g_new(char *, argc);
	for (i = 0; i < argc; i++)
	    argv[i] = g_strdup(PyString_AsString(PyList_GetItem(av, i)));
    } else {
	    argc = 0;
	    argv = NULL;
    }

    if (!clutter_init (&argc, &argv)) {
	if (argv != NULL) {
	    for (i = 0; i < argc; i++)
		g_free(argv[i]);
	    g_free(argv);
	}
	PyErr_SetString(PyExc_RuntimeError, "could not open display");
	/* set the LC_NUMERIC locale back to "C", as Python < 2.4 requires
	 * that it be set that way. */
#if PY_VERSION_HEX < 0x020400F0
	setlocale(LC_NUMERIC, "C");
#endif
	return NULL;
    }
    /* set the LC_NUMERIC locale back to "C", as Python < 2.4 requires that
     * it be set that way. */
#if PY_VERSION_HEX < 0x020400F0
    setlocale(LC_NUMERIC, "C");
#endif
    if (argv != NULL) {
	PySys_SetArgv(argc, argv);
	for (i = 0; i < argc; i++)
	    g_free(argv[i]);
	g_free(argv);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override clutter_texture_get_base_size
static PyObject *
_wrap_clutter_texture_get_base_size (PyGObject *self)
{
	gint width, height;

	clutter_texture_get_base_size (CLUTTER_TEXTURE (self->obj),
				       &width,
				       &height);
	return Py_BuildValue ("(ii)", width, height);
}
%%
override clutter_texture_get_n_tiles
static PyObject *
_wrap_clutter_texture_get_n_tiles (PyGObject *self)
{
	gint n_x_tiles, n_y_tiles;

	clutter_texture_get_n_tiles (CLUTTER_TEXTURE (self->obj),
				     &n_x_tiles,
				     &n_y_tiles);
	return Py_BuildValue ("(ii)", n_x_tiles, n_y_tiles);
}
%%
override clutter_texture_get_x_tile_detail kwargs
static PyObject *
_wrap_clutter_texture_get_x_tile_detail (PyGObject *self,
                                         PyObject  *args,
					 PyObject  *kwargs)
{
	static char *kwlist[] = { "x_index", NULL };
	gint x_index;
	gint pos, size, waste;

	if (!PyArg_ParseTupleAndKeywords (args, kwargs,
					  "i:ClutterTexture.get_x_tile_detail",
					  kwlist, &x_index))
		return NULL;
	
	clutter_texture_get_x_tile_detail (CLUTTER_TEXTURE (self->obj),
					   x_index,
					   &pos, &size, &waste);
	return Py_BuildValue ("(iii)", pos, size, waste);
}
%%
override clutter_texture_get_y_tile_detail kwargs
static PyObject *
_wrap_clutter_texture_get_y_tile_detail (PyGObject *self,
                                         PyObject  *args,
					 PyObject  *kwargs)
{
	static char *kwlist[] = { "y_index", NULL };
	gint y_index;
	gint pos, size, waste;

	if (!PyArg_ParseTupleAndKeywords (args, kwargs,
					  "i:ClutterTexture.get_y_tile_detail",
					  kwlist, &y_index))
		return NULL;
	
	clutter_texture_get_y_tile_detail (CLUTTER_TEXTURE (self->obj),
					   y_index,
					   &pos, &size, &waste);
	return Py_BuildValue ("(iii)", pos, size, waste);
}
%%
override clutter_container_add
static PyObject *
_wrap_clutter_container_add (PyGObject *self,
                             PyObject  *args)
{
	ClutterContainer *container;
	int i, len;

	if ((len = PyTuple_Size(args)) < 1) {
		PyErr_SetString(PyExc_TypeError,
				"requires at least one argument");
		return NULL;
	}

	container = CLUTTER_CONTAINER (self->obj);

	for (i = 0; i < len; i++) {
		PyGObject *pyactor;
		ClutterActor *actor;

		pyactor = (PyGObject *) PyTuple_GetItem (args, i);
		if (!pygobject_check (pyactor, &PyClutterActor_Type)) {
			PyErr_SetString (PyExc_TypeError,
					 "Expected a ClutterActor");
			return NULL;
		}
		
		actor = CLUTTER_ACTOR (pyactor->obj);

		clutter_container_add_actor (container, actor);
	}

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_container_remove
static PyObject *
_wrap_clutter_container_remove (PyGObject *self,
                                PyObject  *args)
{
	ClutterContainer *container;
	int i, len;

	if ((len = PyTuple_Size(args)) < 1) {
		PyErr_SetString(PyExc_TypeError,
				"requires at least one argument");
		return NULL;
	}

	container = CLUTTER_CONTAINER (self->obj);

	for (i = 0; i < len; i++) {
		PyGObject *pyactor;
		ClutterActor *actor;

		pyactor = (PyGObject *) PyTuple_GetItem (args, i);
		if (!pygobject_check (pyactor, &PyClutterActor_Type)) {
			PyErr_SetString (PyExc_TypeError,
					 "Expected a ClutterActor");
			return NULL;
		}
		
		actor = CLUTTER_ACTOR (pyactor->obj);

		clutter_container_remove_actor (container, actor);
	}

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_main noargs
static PyObject *
_wrap_clutter_main (PyObject *self)
{
	pyg_begin_allow_threads;
	clutter_main ();
	pyg_end_allow_threads;

	if (PyErr_Occurred ())
		return NULL;
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_main_quit
static PyObject *
_wrap_clutter_main_quit (PyObject *self, PyObject *args)
{
	/* sanity check to make sure we are in a main loop */
	if (clutter_main_level () == 0) {
		PyErr_SetString (PyExc_RuntimeError,
				 "called outside of a mainloop");
		return NULL;
	}

	clutter_main_quit ();
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_stage_set_color kwargs
static PyObject *
_wrap_clutter_stage_set_color (PyGObject *self,
                               PyObject  *args,
                               PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterStage.set_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_stage_set_color (CLUTTER_STAGE (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_stage_get_color noargs
static PyObject *
_wrap_clutter_stage_get_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_stage_get_color (CLUTTER_STAGE (self->obj), &color);

        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);	
}
%%
override clutter_rectangle_set_color kwargs
static PyObject *
_wrap_clutter_rectangle_set_color (PyGObject *self,
                                   PyObject  *args,
                                   PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color = { 0, };

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterRectangle.set_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_rectangle_set_color (CLUTTER_RECTANGLE (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_rectangle_get_color noargs
static PyObject *
_wrap_clutter_rectangle_get_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_rectangle_get_color (CLUTTER_RECTANGLE (self->obj), &color);

        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override clutter_rectangle_set_border_color kwargs
static PyObject *
_wrap_clutter_rectangle_set_border_color (PyGObject *self,
                                          PyObject  *args,
                                          PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterRectangle.set_border_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_rectangle_set_border_color (CLUTTER_RECTANGLE (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_rectangle_get_border_color noargs
static PyObject *
_wrap_clutter_rectangle_get_border_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_rectangle_get_border_color (CLUTTER_RECTANGLE (self->obj),
                                            &color);
	
        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override clutter_label_set_color kwargs
static PyObject *
_wrap_clutter_label_set_color (PyGObject *self,
                               PyObject  *args,
                               PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterLabel.set_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_label_set_color (CLUTTER_LABEL (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_label_get_color noargs
static PyObject *
_wrap_clutter_label_get_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_label_get_color (CLUTTER_LABEL (self->obj), &color);
	
        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override clutter_container_foreach kwargs
static void
pyclutter_container_foreach (ClutterActor *actor,
                             gpointer      data)
{
        PyClutterCallback *pycb = data;
        PyGILState_STATE state;
        PyObject *py_actor;
        PyObject *retobj;

        state = pyg_gil_state_ensure ();

        py_actor = pygobject_new ((GObject *) actor);
        retobj = pyclutter_callback_invoke (pycb, py_actor);
        if (retobj == NULL)
                PyErr_Print ();

        Py_XDECREF (retobj);

        pyg_gil_state_release (state);
}
static PyObject *
_wrap_clutter_container_foreach (PyGObject *self,
                                 PyObject  *args,
                                 PyObject  *kwargs)
{
        static char *kwlist[] = { "func", "data", NULL };
        PyObject *py_func, *py_data = NULL;
        ClutterContainer *container;
        PyClutterCallback *pycb;
        GType param_types[] = { CLUTTER_TYPE_ACTOR, };

        if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                         "O|O:clutter.Container.foreach",
                                         kwlist,
                                         &py_func, &py_data)) {
                return NULL;
        }

        if (!PyCallable_Check (py_func)) {
                PyErr_SetString (PyExc_TypeError, "func must be callable");
                return NULL;
        }

        pycb = pyclutter_callback_new (py_func, py_data,
                                       1, param_types);

        container = CLUTTER_CONTAINER (self->obj);
        clutter_container_foreach (container, pyclutter_container_foreach, pycb);

        pyclutter_callback_free (pycb);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_container_get_children noargs
static PyObject *
_wrap_clutter_container_get_children (PyGObject *self)
{
        GList *children, *l;
        PyObject *py_list;

        children = clutter_container_get_children (CLUTTER_CONTAINER (self->obj));

        if ((py_list = PyList_New (0)) == NULL) {
                g_list_free (children);
                return NULL;
        }

        for (l = children; l != NULL; l = l->next) {
                ClutterActor *actor = l->data;
                PyObject *py_actor;

                py_actor = pygobject_new ((GObject *) actor);
                if (!py_actor) {
                        g_list_free (children);
                        Py_DECREF (py_list);
                        return NULL;
                }

                PyList_Append (py_list, py_actor);
                Py_DECREF (py_actor);
        }

        g_list_free (children);

        return py_list;
}
%%
override clutter_entry_handle_key_event kwargs
static PyObject *
_wrap_clutter_entry_handle_key_event (PyGObject *self,
                                      PyObject  *args,
                                      PyObject  *kwargs)
{
        static char *kwlist[] = { "event", NULL };
        PyObject *py_event;
        ClutterEvent *event;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:clutter.Entry.handle_key_event",
                                          kwlist,
                                          &py_event))
                return NULL;

        if (!pyg_boxed_check (py_event, CLUTTER_TYPE_EVENT)) {
                PyErr_SetString(PyExc_TypeError, "event must be a clutter.Event");
                return NULL;
        }

        event = pyg_boxed_get (py_event, ClutterEvent);
        clutter_entry_handle_key_event (CLUTTER_ENTRY (self->obj),
                                        (ClutterKeyEvent *) event);
        
        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_stage_get_fog noargs
static PyObject *
_wrap_clutter_stage_get_fog (PyGObject *self)
{
        gdouble density, z_near, z_far;

        clutter_stage_get_fog (CLUTTER_STAGE (self->obj),
                               &density,
                               &z_near,
                               &z_far);

        return Py_BuildValue ("(ddd)", density, z_near, z_far);
}
%%
override clutter_stage_get_perspective noargs
static PyObject *
_wrap_clutter_stage_get_perspective (PyGObject *self)
{
        gfloat fovy, aspect, z_near, z_far;

        clutter_stage_get_perspective (CLUTTER_STAGE (self->obj),
                                       &fovy, &aspect, &z_near, &z_far);

        return Py_BuildValue ("(ffff)", fovy, aspect, z_near, z_far);
}
%%
override clutter_threads_init noargs
static PyObject *
_wrap_clutter_threads_init (PyObject *self)
{
        if (pyg_enable_threads ())
                return NULL;
        
        clutter_threads_init ();

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_threads_enter noargs
static PyObject *
_wrap_clutter_threads_enter (PyObject *self)
{
        /* must allow threads while acquiring lock, or no other python
         * code will execute while we wait
         */
        pyg_begin_allow_threads;
        clutter_threads_enter ();
        pyg_end_allow_threads;

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_timeline_get_delta noargs
static PyObject *
_wrap_clutter_timeline_get_delta (PyGObject *self)
{
  guint frames, msecs;

  frames = clutter_timeline_get_delta (CLUTTER_TIMELINE (self->obj), &msecs);

  return Py_BuildValue ("(ii)", frames, msecs);
}
%%
override clutter_score_list_timelines noargs
static PyObject *
_wrap_clutter_score_list_timelines (PyGObject *self)
{
  GSList *timelines, *l;
  PyObject *py_list;

  timelines = clutter_score_list_timelines (CLUTTER_SCORE (self->obj));

  if ((py_list = PyList_New (0)) == NULL) {
    g_slist_free (timelines);
    return NULL;
  }

  for (l = timelines; l != NULL; l = l->next) {
    ClutterTimeline *timeline = l->data;
    PyObject *py_timeline = NULL;

    py_timeline = pygobject_new ((GObject *) timeline);
    if (!py_timeline) {
      g_slist_free (timelines);
      Py_DECREF (py_list);
      return NULL;
    }

    PyList_Append (py_list, py_timeline);
    Py_DECREF (py_timeline);
  }

  g_slist_free (timelines);

  return py_list;
}
%%
new-constructor CLUTTER_TYPE_STAGE
%%
override clutter_stage_new noargs
static int
_wrap_clutter_stage_new (PyGObject *self)
{
  self->obj = (GObject *) clutter_stage_get_default ();
  if (!self->obj)
    {
      PyErr_SetString (PyExc_RuntimeError, "could not get default display");
      return -1;
    }

  g_object_ref (self->obj);
  pygobject_register_wrapper ((PyObject *) self);

  return 0;
}
