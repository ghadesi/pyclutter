/* -*- C -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include <clutter/clutter.h>
#include <clutter/clutter-feature.h>
%%
include
  clutter-actor.override
  clutter-behaviour.override
  clutter-boxed.override
  clutter-event.override
%%
modulename clutter
%%
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import pango.Context as PyPangoContext_Type
import pango.Font as PyPangoFont_Type
import pango.Layout as PyPangoLayout_Type
%%
ignore
  clutter_group_add_many_valist
  clutter_stage_get_xvisual
  clutter_stage_get_xwindow
  clutter_stage_set_xwindow_foreign
  clutter_init
  clutter_xdisplay
  clutter_root_xwindow
  clutter_gl_context
  clutter_rectangle_new_with_color
%%
ignore-glob
  *_get_type
  _*
%%
override clutter_texture_get_base_size
static PyObject *
_wrap_clutter_texture_get_base_size (PyGObject *self)
{
	gint width, height;

	clutter_texture_get_base_size (CLUTTER_TEXTURE (self->obj),
				       &width,
				       &height);
	return Py_BuildValue ("(ii)", width, height);
}
%%
override clutter_texture_get_n_tiles
static PyObject *
_wrap_clutter_texture_get_n_tiles (PyGObject *self)
{
	gint n_x_tiles, n_y_tiles;

	clutter_texture_get_n_tiles (CLUTTER_TEXTURE (self->obj),
				     &n_x_tiles,
				     &n_y_tiles);
	return Py_BuildValue ("(ii)", n_x_tiles, n_y_tiles);
}
%%
override clutter_texture_get_x_tile_detail kwargs
static PyObject *
_wrap_clutter_texture_get_x_tile_detail (PyGObject *self,
                                         PyObject  *args,
					 PyObject  *kwargs)
{
	static char *kwlist[] = { "x_index", NULL };
	gint x_index;
	gint pos, size, waste;

	if (!PyArg_ParseTupleAndKeywords (args, kwargs,
					  "i:ClutterTexture.get_x_tile_detail",
					  kwlist, &x_index))
		return NULL;
	
	clutter_texture_get_x_tile_detail (CLUTTER_TEXTURE (self->obj),
					   x_index,
					   &pos, &size, &waste);
	return Py_BuildValue ("(iii)", pos, size, waste);
}
%%
override clutter_texture_get_y_tile_detail kwargs
static PyObject *
_wrap_clutter_texture_get_y_tile_detail (PyGObject *self,
                                         PyObject  *args,
					 PyObject  *kwargs)
{
	static char *kwlist[] = { "y_index", NULL };
	gint y_index;
	gint pos, size, waste;

	if (!PyArg_ParseTupleAndKeywords (args, kwargs,
					  "i:ClutterTexture.get_y_tile_detail",
					  kwlist, &y_index))
		return NULL;
	
	clutter_texture_get_y_tile_detail (CLUTTER_TEXTURE (self->obj),
					   y_index,
					   &pos, &size, &waste);
	return Py_BuildValue ("(iii)", pos, size, waste);
}
%%
override clutter_group_add_many
static PyObject *
_wrap_clutter_group_add_many (PyGObject *self,
			      PyObject  *args)
{
	ClutterGroup *group;
	int i, len;

	if ((len = PyTuple_Size(args)) < 1) {
		PyErr_SetString(PyExc_TypeError,
				"requires at least one argument");
		return NULL;
	}

	group = CLUTTER_GROUP (self->obj);

	for (i = 0; i < len; i++) {
		PyGObject *pyactor;
		ClutterActor *actor;

		pyactor = (PyGObject *) PyTuple_GetItem (args, i);
		if (!pygobject_check (pyactor, &PyClutterActor_Type)) {
			PyErr_SetString (PyExc_TypeError,
					 "Expected a ClutterActor");
			return NULL;
		}
		
		actor = CLUTTER_ACTOR (pyactor->obj);

		clutter_group_add (group, actor);
	}

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_behaviour_path_append_knots
static PyObject *
_wrap_clutter_behaviour_path_append_knots (PyGObject *object,
                                           PyObject  *args)
{
  Py_INCREF (Py_None);
  return Py_None;
}
%%
override clutter_main noargs
static PyObject *
_wrap_clutter_main (PyObject *self)
{
	pyg_begin_allow_threads;
	clutter_main ();
	pyg_end_allow_threads;

	if (PyErr_Occurred ())
		return NULL;
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_main_quit
static PyObject *
_wrap_clutter_main_quit (PyObject *self, PyObject *args)
{
	/* sanity check to make sure we are in a main loop */
	if (clutter_main_level () == 0) {
		PyErr_SetString (PyExc_RuntimeError,
				 "called outside of a mainloop");
		return NULL;
	}

	clutter_main_quit ();
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_threads_enter noargs
static PyObject *
_wrap_clutter_threads_enter (PyObject *self)
{
	/* must allow threads while acquiring lock, or no other python
         * code will execute while we wait! */
	pyg_begin_allow_threads;
	clutter_threads_enter ();
	pyg_end_allow_threads;

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override clutter_stage_set_color
static PyObject *
_wrap_clutter_stage_set_color (PyGObject *self,
			       PyObject  *args)
{
	ClutterColor color;
	int len, i;

	if ((len = PyTuple_Size (args)) != 4) {
		PyErr_SetString (PyExc_TypeError,
				 "requires a tuple of 4 integers: (r, g, b, a)");
		return NULL;
	}

	for (i = 0; i < len; i++) {
		PyObject *comp = PyTuple_GetItem (args, i);
		
		if (!PyInt_Check (comp)) {
			PyErr_SetString (PyExc_TypeError,
					 "component is not an integer");
			return NULL;
		}
		
		switch (i) {
			case 0: color.red   = (guint8) PyInt_AsLong (comp); break;
			case 1: color.green = (guint8) PyInt_AsLong (comp); break;
			case 2: color.blue  = (guint8) PyInt_AsLong (comp); break;
			case 3: color.alpha = (guint8) PyInt_AsLong (comp); break;
			default:
				g_assert_not_reached ();
				break;
		}
	}
	
	clutter_stage_set_color (CLUTTER_STAGE (self->obj), &color);

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_stage_get_color
static PyObject *
_wrap_clutter_stage_get_color (PyGObject *self,
			       PyObject  *args)
{
	ClutterColor color;

	clutter_stage_get_color (CLUTTER_STAGE (self->obj), &color);
	
	return Py_BuildValue ("(iiii)", color.red,
					color.green,
					color.blue,
					color.alpha);
}
%%
override clutter_color_to_hls
static PyObject *
_wrap_clutter_color_to_hls (PyObject *self,
			    PyObject *args)
{
	ClutterColor color;
	guint8 h, l, s;
	int i;

	if (PyTuple_Size (args) != 4) {
		PyErr_SetString (PyExc_TypeError,
				 "requires a tuple of 4 integers: (r, g, b, a)");
		return NULL;
	}

	for (i = 0; i < 4; i++) {
		PyObject *comp = PyTuple_GetItem (args, i);

		if (!PyInt_Check (comp)) {
			PyErr_SetString (PyExc_TypeError,
					 "component is not an integer");
			return NULL;
		}

		switch (i) {
			case 0: color.red   = (guint8) PyInt_AsLong (comp); break;
			case 1: color.green = (guint8) PyInt_AsLong (comp); break;
			case 2: color.blue  = (guint8) PyInt_AsLong (comp); break;
			case 3: color.alpha = (guint8) PyInt_AsLong (comp); break;
			default:
				g_assert_not_reached ();
				break;
		}
	}

	clutter_color_to_hls (&color, &h, &l, &s);

	return Py_BuildValue ("(iii)", (int) h, (int) l, (int) s);
}
%%
override clutter_color_from_hls
static PyObject *
_wrap_clutter_color_from_hls (PyObject *self,
			      PyObject *args)
{
	ClutterColor color;
	guint8 h, l, s;
	int i;

	if (PyTuple_Size (args) != 3) {
		PyErr_SetString (PyExc_TypeError,
				 "requires a tuple of 3 integers: (h, l, s)");
		return NULL;
	}

	h = l = s = 0;
	for (i = 0; i < 3; i++) {
		PyObject *comp = PyTuple_GetItem (args, i);

		if (!PyInt_Check (comp)) {
			PyErr_SetString (PyExc_TypeError,
					 "component is not an integer");
			return NULL;
		}

		switch (i) {
			case 0: h = (guint8) PyInt_AsLong (comp); break;
			case 1: l = (guint8) PyInt_AsLong (comp); break;
			case 2: s = (guint8) PyInt_AsLong (comp); break;
			default:
				g_assert_not_reached ();
				break;
		}
	}

	clutter_color_from_hls (&color, h, l, s);

	return Py_BuildValue ("(iiii)",
			      (int) color.red,
			      (int) color.green,
			      (int) color.blue,
			      (int) color.alpha);
}
%%
override clutter_color_to_pixel
static PyObject *
_wrap_clutter_color_to_pixel (PyObject *self,
			      PyObject *args)
{
	ClutterColor color;
	guint32 pixel;
	int i;

	if (PyTuple_Size (args) != 4) {
		PyErr_SetString (PyExc_TypeError,
				 "requires a tuple of 4 integers: (r, g, b, a)");
		return NULL;
	}

	for (i = 0; i < 4; i++) {
		PyObject *comp = PyTuple_GetItem (args, i);

		if (!PyInt_Check (comp)) {
			PyErr_SetString (PyExc_TypeError,
					 "component is not an integer");
			return NULL;
		}

		switch (i) {
			case 0: color.red   = (guint8) PyInt_AsLong (comp); break;
			case 1: color.green = (guint8) PyInt_AsLong (comp); break;
			case 2: color.blue  = (guint8) PyInt_AsLong (comp); break;
			case 3: color.alpha = (guint8) PyInt_AsLong (comp); break;
			default:
				g_assert_not_reached ();
				break;
		}
	}

	pixel = clutter_color_to_pixel (&color);

	return PyInt_FromLong (pixel);
}
%%
override clutter_color_from_pixel
static PyObject *
_wrap_clutter_color_from_pixel (PyObject *self,
			        PyObject *args)
{
	ClutterColor color;
	guint32 pixel;

	if (!PyInt_Check (args)) {
		PyErr_SetString (PyExc_TypeError,
				 "requires a 32 bit encoded integer");
		return NULL;
	}

	pixel = (guint32) PyInt_AsLong (args);

	clutter_color_from_pixel (&color, pixel);

	return Py_BuildValue ("(iiii)",
			      (int) color.red,
			      (int) color.green,
			      (int) color.blue,
			      (int) color.alpha);
}
%%
override clutter_rectangle_set_color
static PyObject *
_wrap_clutter_rectangle_set_color (PyGObject *self,
				   PyObject  *args)
{
	ClutterColor color;
	int len, i;

	if ((len = PyTuple_Size (args)) != 4) {
		PyErr_SetString (PyExc_TypeError,
				 "requires a tuple of 4 integers: (r, g, b, a)");
		return NULL;
	}

	for (i = 0; i < len; i++) {
		PyObject *comp = PyTuple_GetItem (args, i);
		
		if (!PyInt_Check (comp)) {
			PyErr_SetString (PyExc_TypeError,
					 "component is not an integer");
			return NULL;
		}
		
		switch (i) {
			case 0: color.red   = (guint8) PyInt_AsLong (comp); break;
			case 1: color.green = (guint8) PyInt_AsLong (comp); break;
			case 2: color.blue  = (guint8) PyInt_AsLong (comp); break;
			case 3: color.alpha = (guint8) PyInt_AsLong (comp); break;
			default:
				g_assert_not_reached ();
				break;
		}
	}
	
	clutter_rectangle_set_color (CLUTTER_RECTANGLE (self->obj), &color);

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_rectangle_get_color
static PyObject *
_wrap_clutter_rectangle_get_color (PyGObject *self,
				   PyObject  *args)
{
	ClutterColor color;

	clutter_rectangle_get_color (CLUTTER_RECTANGLE (self->obj), &color);
	
	return Py_BuildValue ("(iiii)", color.red,
					color.green,
					color.blue,
					color.alpha);
}
%%
override clutter_label_set_color
static PyObject *
_wrap_clutter_label_set_color (PyGObject *self,
			       PyObject  *args)
{
	ClutterColor color;
	int len, i;

	if ((len = PyTuple_Size (args)) != 4) {
		PyErr_SetString (PyExc_TypeError,
				 "requires a tuple of 4 integers: (r, g, b, a)");
		return NULL;
	}

	for (i = 0; i < len; i++) {
		PyObject *comp = PyTuple_GetItem (args, i);
		
		if (!PyInt_Check (comp)) {
			PyErr_SetString (PyExc_TypeError,
					 "component is not an integer");
			return NULL;
		}
		
		switch (i) {
			case 0: color.red   = (guint8) PyInt_AsLong (comp); break;
			case 1: color.green = (guint8) PyInt_AsLong (comp); break;
			case 2: color.blue  = (guint8) PyInt_AsLong (comp); break;
			case 3: color.alpha = (guint8) PyInt_AsLong (comp); break;
			default:
				g_assert_not_reached ();
				break;
		}
	}
	
	clutter_label_set_color (CLUTTER_LABEL (self->obj), &color);

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_label_get_color
static PyObject *
_wrap_clutter_label_get_color (PyGObject *self,
			       PyObject  *args)
{
	ClutterColor color;

	clutter_label_get_color (CLUTTER_LABEL (self->obj), &color);
	
	return Py_BuildValue ("(iiii)", color.red,
					color.green,
					color.blue,
					color.alpha);
}

