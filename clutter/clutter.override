/* -*- C -*- */
%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include "pyclutter.h"
%%
include
  clutter-actor.override
  clutter-behaviour.override
  clutter-boxed.override
  clutter-color.override
  clutter-event.override
%%
modulename clutter
%%
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import pango.Context as PyPangoContext_Type
import pango.Font as PyPangoFont_Type
import pango.Layout as PyPangoLayout_Type
%%
ignore
  clutter_init
  clutter_init_with_args
  clutter_backend_get_event
  clutter_backend_put_event
  clutter_backend_peek_event
  clutter_get_option_group
  clutter_rectangle_new_with_color
  clutter_stage_set_perspectivex
  clutter_stage_get_perspectivex
  clutter_container_add_actor
  clutter_container_add_valist
  clutter_container_remove_actor
  clutter_container_remove_valist
  clutter_sine_inc_func
  clutter_sine_dec_func
  clutter_sine_half_func
  clutter_square_func
  clutter_smoothstep_inc_func
  clutter_smoothstep_dec_func
  clutter_exp_inc_func
  clutter_exp_dec_func
  clutter_effect_template_new_full
  clutter_effect_fade
  clutter_effect_move
  clutter_effect_scale
  clutter_effect_rotate_x
  clutter_effect_rotate_y
  clutter_effect_rotate_z
%%
ignore-glob
  *_quark
  *_get_type
  _*
%%
override clutter_texture_get_base_size
static PyObject *
_wrap_clutter_texture_get_base_size (PyGObject *self)
{
	gint width, height;

	clutter_texture_get_base_size (CLUTTER_TEXTURE (self->obj),
				       &width,
				       &height);
	return Py_BuildValue ("(ii)", width, height);
}
%%
override clutter_texture_get_n_tiles
static PyObject *
_wrap_clutter_texture_get_n_tiles (PyGObject *self)
{
	gint n_x_tiles, n_y_tiles;

	clutter_texture_get_n_tiles (CLUTTER_TEXTURE (self->obj),
				     &n_x_tiles,
				     &n_y_tiles);
	return Py_BuildValue ("(ii)", n_x_tiles, n_y_tiles);
}
%%
override clutter_texture_get_x_tile_detail kwargs
static PyObject *
_wrap_clutter_texture_get_x_tile_detail (PyGObject *self,
                                         PyObject  *args,
					 PyObject  *kwargs)
{
	static char *kwlist[] = { "x_index", NULL };
	gint x_index;
	gint pos, size, waste;

	if (!PyArg_ParseTupleAndKeywords (args, kwargs,
					  "i:ClutterTexture.get_x_tile_detail",
					  kwlist, &x_index))
		return NULL;
	
	clutter_texture_get_x_tile_detail (CLUTTER_TEXTURE (self->obj),
					   x_index,
					   &pos, &size, &waste);
	return Py_BuildValue ("(iii)", pos, size, waste);
}
%%
override clutter_texture_get_y_tile_detail kwargs
static PyObject *
_wrap_clutter_texture_get_y_tile_detail (PyGObject *self,
                                         PyObject  *args,
					 PyObject  *kwargs)
{
	static char *kwlist[] = { "y_index", NULL };
	gint y_index;
	gint pos, size, waste;

	if (!PyArg_ParseTupleAndKeywords (args, kwargs,
					  "i:ClutterTexture.get_y_tile_detail",
					  kwlist, &y_index))
		return NULL;
	
	clutter_texture_get_y_tile_detail (CLUTTER_TEXTURE (self->obj),
					   y_index,
					   &pos, &size, &waste);
	return Py_BuildValue ("(iii)", pos, size, waste);
}
%%
override clutter_group_add_many
static PyObject *
_wrap_clutter_group_add_many (PyGObject *self,
			      PyObject  *args)
{
	ClutterGroup *group;
	int i, len;

	if ((len = PyTuple_Size(args)) < 1) {
		PyErr_SetString(PyExc_TypeError,
				"requires at least one argument");
		return NULL;
	}

	group = CLUTTER_GROUP (self->obj);

	for (i = 0; i < len; i++) {
		PyGObject *pyactor;
		ClutterActor *actor;

		pyactor = (PyGObject *) PyTuple_GetItem (args, i);
		if (!pygobject_check (pyactor, &PyClutterActor_Type)) {
			PyErr_SetString (PyExc_TypeError,
					 "Expected a ClutterActor");
			return NULL;
		}
		
		actor = CLUTTER_ACTOR (pyactor->obj);

		clutter_group_add (group, actor);
	}

	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_main noargs
static PyObject *
_wrap_clutter_main (PyObject *self)
{
	pyg_begin_allow_threads;
	clutter_main ();
	pyg_end_allow_threads;

	if (PyErr_Occurred ())
		return NULL;
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_main_quit
static PyObject *
_wrap_clutter_main_quit (PyObject *self, PyObject *args)
{
	/* sanity check to make sure we are in a main loop */
	if (clutter_main_level () == 0) {
		PyErr_SetString (PyExc_RuntimeError,
				 "called outside of a mainloop");
		return NULL;
	}

	clutter_main_quit ();
	Py_INCREF (Py_None);
	return Py_None;
}
%%
override clutter_threads_enter noargs
static PyObject *
_wrap_clutter_threads_enter (PyObject *self)
{
	/* must allow threads while acquiring lock, or no other python
         * code will execute while we wait! */
	pyg_begin_allow_threads;
	clutter_threads_enter ();
	pyg_end_allow_threads;

	Py_INCREF(Py_None);
	return Py_None;
}
%%
override clutter_stage_set_color kwargs
static PyObject *
_wrap_clutter_stage_set_color (PyGObject *self,
                               PyObject  *args,
                               PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterStage.set_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_stage_set_color (CLUTTER_STAGE (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_stage_get_color noargs
static PyObject *
_wrap_clutter_stage_get_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_stage_get_color (CLUTTER_STAGE (self->obj), &color);

        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);	
}
%%
override clutter_rectangle_set_color kwargs
static PyObject *
_wrap_clutter_rectangle_set_color (PyGObject *self,
                                   PyObject  *args,
                                   PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color = { 0, };

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterRectangle.set_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_rectangle_set_color (CLUTTER_RECTANGLE (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_rectangle_get_color noargs
static PyObject *
_wrap_clutter_rectangle_get_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_rectangle_get_color (CLUTTER_RECTANGLE (self->obj), &color);

        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override clutter_rectangle_set_border_color kwargs
static PyObject *
_wrap_clutter_rectangle_set_border_color (PyGObject *self,
                                          PyObject  *args,
                                          PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterRectangle.set_border_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_rectangle_set_border_color (CLUTTER_RECTANGLE (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_rectangle_get_border_color noargs
static PyObject *
_wrap_clutter_rectangle_get_border_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_rectangle_get_border_color (CLUTTER_RECTANGLE (self->obj),
                                            &color);
	
        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override clutter_label_set_color kwargs
static PyObject *
_wrap_clutter_label_set_color (PyGObject *self,
                               PyObject  *args,
                               PyObject  *kwargs)
{
        static char *kwlist[] = { "color", NULL };
        PyObject *py_color;
        ClutterColor color;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterLabel.set_color", kwlist,
                                          &py_color)) {
                return NULL;
        }

        if (!pyg_boxed_check (py_color, CLUTTER_TYPE_COLOR)) {
                if (!pyclutter_color_from_pyobject (py_color, &color)) {
                        PyErr_Clear ();
                        PyErr_SetString (PyExc_TypeError,
                                         "color must be a ClutterColor or 4-tuple");
                        return NULL;
                }
        }
        else {
                color = *pyg_boxed_get (py_color, ClutterColor);
        }

        clutter_label_set_color (CLUTTER_LABEL (self->obj), &color);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_label_get_color noargs
static PyObject *
_wrap_clutter_label_get_color (PyGObject *self)
{
	ClutterColor color = { 0, };

	clutter_label_get_color (CLUTTER_LABEL (self->obj), &color);
	
        return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override clutter_group_foreach kwargs
static void
pyclutter_group_foreach (ClutterActor *actor,
                         gpointer      data)
{
        PyClutterCallback *pycb = data;
        PyGILState_STATE state;
        PyObject *py_actor;
        PyObject *retobj;

        state = pyg_gil_state_ensure ();

        py_actor = pygobject_new ((GObject *) actor);
        retobj = pyclutter_callback_invoke (pycb, py_actor);
        if (retobj == NULL)
                PyErr_Print ();

        Py_XDECREF (retobj);

        pyg_gil_state_release (state);
}
static PyObject *
_wrap_clutter_group_foreach (PyGObject *self,
                             PyObject  *args,
                             PyObject  *kwargs)
{
        static char *kwlist[] = { "func", "data", NULL };
        PyObject *py_func, *py_data = NULL;
        ClutterGroup *group;
        PyClutterCallback *pycb;
        GType param_types[] = { CLUTTER_TYPE_ACTOR, };

        if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                         "O|O:clutter.Group.foreach",
                                         kwlist,
                                         &py_func, &py_data)) {
                return NULL;
        }

        if (!PyCallable_Check (py_func)) {
                PyErr_SetString (PyExc_TypeError, "func must be callable");
                return NULL;
        }

        pycb = pyclutter_callback_new (py_func, py_data,
                                       1, param_types);
        group = CLUTTER_GROUP (self->obj);

        clutter_group_foreach (group,
                               pyclutter_group_foreach,
                               pycb);

        pyclutter_callback_free (pycb);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_group_get_children noargs
static PyObject *
_wrap_clutter_group_get_children (PyGObject *self)
{
        GList *children, *l;
        PyObject *py_list;

        children = clutter_group_get_children (CLUTTER_GROUP (self->obj));

        if ((py_list = PyList_New (0)) == NULL) {
                g_list_free (children);
                return NULL;
        }

        for (l = children; l != NULL; l = l->next) {
                ClutterActor *actor = l->data;
                PyObject *py_actor;

                py_actor = pygobject_new ((GObject *) actor);
                if (!py_actor) {
                        g_list_free (children);
                        Py_DECREF (py_list);
                        return NULL;
                }

                PyList_Append (py_list, py_actor);
                Py_DECREF (py_actor);
        }

        g_list_free (children);

        return py_list;
}

