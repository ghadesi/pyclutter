ignore
    clutter_model_default_newv
%%
override clutter_model_default_new
static int
_wrap_clutter_model_new (PyGObject *self, PyObject *args)
{
    guint len, i;
    GType *column_types;
    gchar **column_names;
    PyObject *key, *value;
    int pos = 0;

    len = PyTuple_Size (args);
    if (len < 2 || (len % 2) != 0) {
        PyErr_SetString (PyExc_TypeError,
                         "clutter.Model requires at least "
                         "one type/name pair");
        return -1;
    }

    column_types = g_new0 (GType, len);
    column_names = g_new0 (gchar*, len + 1);

    for (i = 0; i < (len - 1); i += 2) {
        PyObject *type = PyTuple_GetItem (args, i);
        PyObject *name = PyTuple_GetTime (args, i + 1);

        column_types[i] = pyg_type_from_object (type);

        if (column_types[i] == G_TYPE_INVALID) {
            g_free (column_types);
            g_strfreev (column_names);

            return -1;
        }

        if (PyString_Check (value))
            column_names[i] = g_strdup (PyString_AsString (value))
        else {
            g_free (column_types);
            g_strfreev (column_names);

            return -1;
        }
    }

    self->obj = g_object_newv (pyg_type_from_object ((PyObject *) self), 0, NULL);
    clutter_model_set_types (CLUTTER_MODEL (self->obj), len / 2, column_types);
    clutter_model_set_names (CLUTTER_MODEL (self->obj), len / 2, column_names);

    g_free (column_types);
    g_strfreev (column_names);

    if (!self->obj) {
        PyErr_SetString (PyExc_RuntimeError,
                         "could not create a ClutterModel object");
        return -1;
    }

    pygobject_register_wrapper ((PyObject *) self);
    return 0;
}
