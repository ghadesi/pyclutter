%%
ignore
  clutter_actor_get_allocation_vertices
  clutter_actor_get_abs_allocation_vertices
  clutter_actor_set_scalex
  clutter_actor_get_scalex
  clutter_actor_set_rotationx
  clutter_actor_get_rotationx
%%
override clutter_actor_get_allocation_geometry noargs
static PyObject *
_wrap_clutter_actor_get_allocation_geometry (PyGObject *self)
{
        ClutterGeometry geom = { 0, };

        clutter_actor_get_allocation_geometry (CLUTTER_ACTOR (self->obj), &geom);

        return Py_BuildValue ("(iiii)",
                              geom.x, geom.y, geom.width, geom.height);
}
%%
override clutter_actor_get_geometry noargs
static PyObject *
_wrap_clutter_actor_get_geometry (PyGObject *self)
{
        ClutterGeometry geom = { 0, };

        clutter_actor_get_geometry (CLUTTER_ACTOR (self->obj), &geom);

        return Py_BuildValue ("(iiii)",
                              geom.x, geom.y, geom.width, geom.height);
}
%%
override clutter_actor_set_geometry kwargs
static PyObject *
_wrap_clutter_actor_set_geometry (PyGObject *self,
                                  PyObject  *args,
                                  PyObject  *kwargs)
{
        static char *kwlist[] = { "geometry", NULL };
        PyObject *py_geom;
        ClutterGeometry geom;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterActor.set_geometry", kwlist,
                                          &py_geom)) {
                return NULL;
        }

        if (!pyclutter_geometry_from_pyobject (py_geom, &geom)) {
                PyErr_Clear ();
                PyErr_SetString (PyExc_TypeError,
                                 "color must be a ClutterGeometry or 4-tuple");
                return NULL;
        }

        clutter_actor_set_geometry (CLUTTER_ACTOR (self->obj), &geom);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_actor_get_allocation_coords noargs
static PyObject *
_wrap_clutter_actor_get_allocation_coords (PyGObject *self)
{
	gint x1, y1;
	gint x2, y2;

	clutter_actor_get_allocation_coords (CLUTTER_ACTOR (self->obj),
				             &x1, &y1,
				             &x2, &y2);
	return Py_BuildValue("(iiii)", x1, y1, x2, y2);
}
%%
override clutter_actor_get_transformed_position noargs
static PyObject *
_wrap_clutter_actor_get_transformed_position (PyGObject *self)
{
	gint pos_x, pos_y;

	clutter_actor_get_transformed_position (CLUTTER_ACTOR (self->obj),
                                                &pos_x,
                                                &pos_y);
	return Py_BuildValue("(ii)", pos_x, pos_y);
}
%%
override clutter_actor_get_transformed_positionu noargs
static PyObject *
_wrap_clutter_actor_get_transformed_positionu (PyGObject *self)
{
        ClutterUnit pos_x, pos_y;

	clutter_actor_get_transformed_positionu (CLUTTER_ACTOR (self->obj),
                                                 &pos_x,
                                                 &pos_y);
	return Py_BuildValue("(dd)",
                             CLUTTER_UNITS_TO_FLOAT (pos_x),
                             CLUTTER_UNITS_TO_FLOAT (pos_y));
}
%%
override clutter_actor_get_transformed_size noargs
static PyObject *
_wrap_clutter_actor_get_transformed_size (PyGObject *self)
{
        guint width, height;

        clutter_actor_get_transformed_size (CLUTTER_ACTOR (self->obj),
                                            &width,
                                            &height);
        return Py_BuildValue ("(ii)", width, height);
}
%%
override clutter_actor_get_transformed_sizeu noargs
static PyObject *
_wrap_clutter_actor_get_transformed_sizeu (PyGObject *self)
{
        ClutterUnit width, height;

        clutter_actor_get_transformed_sizeu (CLUTTER_ACTOR (self->obj),
                                             &width,
                                             &height);
        return Py_BuildValue ("(dd)",
                              CLUTTER_UNITS_TO_FLOAT (width),
                              CLUTTER_UNITS_TO_FLOAT (height));
}
%%
override clutter_actor_transform_stage_point kwargs
static PyObject *
_wrap_clutter_actor_transform_stage_point (PyGObject *self,
                                           PyObject  *args,
                                           PyObject  *kwargs)
{
        static char *kwlist[] = { "x", "y", NULL };
        ClutterUnit x_out, y_out;
        gboolean res;
        double x, y;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "dd:ClutterActor.transform_stage_point", kwlist,
                                          &x, &y)) {
                return NULL;
        }

        x_out = y_out = 0;
        res = clutter_actor_transform_stage_point (CLUTTER_ACTOR (self->obj),
                                                   CLUTTER_UNITS_FROM_FLOAT (x),
                                                   CLUTTER_UNITS_FROM_FLOAT (y),
                                                   &x_out, &y_out);

        if (res)
                return Py_BuildValue ("(dd)",
                                      CLUTTER_UNITS_TO_FLOAT (x_out),
                                      CLUTTER_UNITS_TO_FLOAT (y_out));
        else {
                PyErr_SetString (PyClutterException, "Transformation failed");
                return NULL;
        }
}
%%
override clutter_actor_get_size noargs
static PyObject *
_wrap_clutter_actor_get_size (PyGObject *self)
{
        guint width, height;

        clutter_actor_get_size (CLUTTER_ACTOR (self->obj),
                                &width,
                                &height);
        return Py_BuildValue ("(ii)", width, height);
}
%%
override clutter_actor_set_sizeu kwargs
static PyObject *
_wrap_clutter_actor_set_sizeu (PyGObject *self,
                               PyObject  *args,
                               PyObject  *kwargs)
{
        static char *kwlist[] = { "width", "height", NULL };
        double width, height;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "dd:ClutterActor.set_sizeu",
                                          kwlist,
                                          &width,
                                          &height)) {
                return NULL;
        }

        clutter_actor_set_sizeu (CLUTTER_ACTOR (self->obj),
                                 CLUTTER_UNITS_FROM_FLOAT (width),
                                 CLUTTER_UNITS_FROM_FLOAT (height));

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_actor_get_sizeu noargs
static PyObject *
_wrap_clutter_actor_get_sizeu (PyGObject *self)
{
        ClutterUnit width, height;

        clutter_actor_get_sizeu (CLUTTER_ACTOR (self->obj),
                                 &width,
                                 &height);
        return Py_BuildValue ("(dd)",
                              CLUTTER_UNITS_TO_FLOAT (width),
                              CLUTTER_UNITS_TO_FLOAT (height));
}
%%
override clutter_actor_get_position noargs
static PyObject *
_wrap_clutter_actor_get_position (PyGObject *self)
{
        gint x, y;

        clutter_actor_get_position (CLUTTER_ACTOR (self->obj), &x, &y);

        return Py_BuildValue ("(ii)", x, y);
}
%%
override clutter_actor_set_positionu kwargs
static PyObject *
_wrap_clutter_actor_set_positionu (PyGObject *self,
                                   PyObject  *args,
                                   PyObject  *kwargs)
{
        static char *kwlist[] = { "x", "y", NULL };
        double x, y;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "dd:ClutterActor.set_positionu",
                                          kwlist,
                                          &x, &y)) {
                return NULL;
        }

        clutter_actor_set_positionu (CLUTTER_ACTOR (self->obj),
                                     CLUTTER_UNITS_FROM_FLOAT (x),
                                     CLUTTER_UNITS_FROM_FLOAT (y));

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_actor_get_positionu noargs
static PyObject *
_wrap_clutter_actor_get_positionu (PyGObject *self)
{
        ClutterUnit x, y;

        clutter_actor_get_positionu (CLUTTER_ACTOR (self->obj), &x, &y);

        return Py_BuildValue ("(dd)",
                              CLUTTER_UNITS_TO_FLOAT (x),
                              CLUTTER_UNITS_TO_FLOAT (y));
}
%%
override clutter_actor_get_scale noargs
static PyObject *
_wrap_clutter_actor_get_scale (PyGObject *self)
{
        double scale_x, scale_y;

        clutter_actor_get_scale (CLUTTER_ACTOR (self->obj),
                                 &scale_x,
                                 &scale_y);
        return Py_BuildValue ("(dd)", scale_x, scale_y);
}
%%
override clutter_actor_set_rotation kwargs
static PyObject *
_wrap_clutter_actor_set_rotation (PyGObject *self,
                                  PyObject  *args,
                                  PyObject  *kwargs)
{
        static char *kwlist[] = { "axis", "angle", "x", "y", "z", NULL };
        int axis;
        double angle;
        int x, y, z;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "idiii:ClutterActor.set_rotation",
                                          kwlist,
                                          &axis,
                                          &angle,
                                          &x, &y, &z)) {
                return NULL;
        }

        clutter_actor_set_rotation (CLUTTER_ACTOR (self->obj), axis,
                                    angle,
                                    x, y, z);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_actor_set_rotationu kwargs
static PyObject *
_wrap_clutter_actor_set_rotationu (PyGObject *self,
                                   PyObject  *args,
                                   PyObject  *kwargs)
{
        static char *kwlist[] = { "axis", "angle", "x", "y", "z", NULL };
        int axis;
        double angle;
        double x, y, z;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "idddd:ClutterActor.set_rotation",
                                          kwlist,
                                          &axis,
                                          &angle,
                                          &x, &y, &z)) {
                return NULL;
        }

        clutter_actor_set_rotationu (CLUTTER_ACTOR (self->obj), axis,
                                     angle,
                                     CLUTTER_UNITS_FROM_FLOAT (x),
                                     CLUTTER_UNITS_FROM_FLOAT (y),
                                     CLUTTER_UNITS_FROM_FLOAT (z));

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_actor_get_rotation kwargs
static PyObject *
_wrap_clutter_actor_get_rotation (PyGObject *self,
                                  PyObject  *args,
                                  PyObject  *kwargs)
{
        static char *kwlist[] = { "axis", NULL };
        int axis;
        gint center_x, center_y, center_z;
        gdouble angle;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "i:ClutterActor.get_rotation", kwlist,
                                          &axis)) {
                return NULL;
        }

        angle = clutter_actor_get_rotation (CLUTTER_ACTOR (self->obj), axis,
                                            &center_x,
                                            &center_y,
                                            &center_z);

        return Py_BuildValue ("(diii)",
                              angle,
                              center_x, center_y, center_z);
}
%%
override clutter_actor_get_rotationu kwargs
static PyObject *
_wrap_clutter_actor_get_rotationu (PyGObject *self,
                                   PyObject  *args,
                                   PyObject  *kwargs)
{
        static char *kwlist[] = { "axis", NULL };
        int axis;
        gint32 center_x, center_y, center_z;
        gdouble angle;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "i:ClutterActor.get_rotation", kwlist,
                                          &axis)) {
                return NULL;
        }

        angle = clutter_actor_get_rotationu (CLUTTER_ACTOR (self->obj), axis,
                                             &center_x,
                                             &center_y,
                                             &center_z);

        return Py_BuildValue ("(dddd)",
                              angle,
                              CLUTTER_UNITS_TO_FLOAT (center_x),
                              CLUTTER_UNITS_TO_FLOAT (center_y),
                              CLUTTER_UNITS_TO_FLOAT (center_z));
}
%%
override clutter_actor_get_clip noargs
static PyObject *
_wrap_clutter_actor_get_clip (PyGObject *self)
{
	gint xoff, yoff;
	gint width, height;

	clutter_actor_get_clip (CLUTTER_ACTOR (self->obj),
                                &xoff, &yoff,
                                &width, &height);
	return Py_BuildValue("(iiii)", xoff, yoff, width, height);
}
%%
override clutter_actor_set_clipu kwargs
static PyObject *
_wrap_clutter_actor_set_clipu (PyGObject *self,
                               PyObject  *args,
                               PyObject  *kwargs)
{
        static char *kwlist[] = { "x_offset", "y_offset", "width", "height", NULL };
        double xoffset, yoffset, width, height;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "dddd:ClutterActor.set_clipu",
                                          kwlist,
                                          &xoffset,
                                          &yoffset,
                                          &width,
                                          &height)) {
                return NULL;
        }

        clutter_actor_set_clipu (CLUTTER_ACTOR (self->obj),
                                 CLUTTER_UNITS_FROM_FLOAT (xoffset),
                                 CLUTTER_UNITS_FROM_FLOAT (yoffset),
                                 CLUTTER_UNITS_FROM_FLOAT (width),
                                 CLUTTER_UNITS_FROM_FLOAT (height));

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_actor_get_clipu noargs
static PyObject *
_wrap_clutter_actor_get_clipu (PyGObject *self)
{
	ClutterUnit xoff, yoff;
	ClutterUnit width, height;

	clutter_actor_get_clipu (CLUTTER_ACTOR (self->obj),
                                 &xoff, &yoff,
                                 &width, &height);

	return Py_BuildValue("(dddd)",
                             CLUTTER_UNITS_TO_FLOAT (xoff),
                             CLUTTER_UNITS_TO_FLOAT (yoff),
                             CLUTTER_UNITS_TO_FLOAT (width),
                             CLUTTER_UNITS_TO_FLOAT (height));
}
%%
override clutter_actor_get_allocation_box noargs
static PyObject *
_wrap_clutter_actor_get_allocation_box (PyGObject *self)
{
        ClutterActorBox box = { 0, };

        clutter_actor_get_allocation_box (CLUTTER_ACTOR (self->obj), &box);

        return Py_BuildValue ("(dddd)",
                              CLUTTER_UNITS_TO_FLOAT (box.x1),
                              CLUTTER_UNITS_TO_FLOAT (box.y1),
                              CLUTTER_UNITS_TO_FLOAT (box.x2),
                              CLUTTER_UNITS_TO_FLOAT (box.y2));
}
%%
override clutter_actor_get_preferred_size noargs
static PyObject *
_wrap_clutter_actor_get_preferred_size (PyGObject *self)
{
        ClutterUnit min_width, natural_width;
        ClutterUnit min_height, natural_height;

        min_width = natural_width = 0;
        min_height = natural_height = 0;
        clutter_actor_get_preferred_size (CLUTTER_ACTOR (self->obj),
                                          &min_width, &min_height,
                                          &natural_width, &natural_height);

        return Py_BuildValue ("(dddd)",
                              CLUTTER_UNITS_TO_FLOAT (min_width),
                              CLUTTER_UNITS_TO_FLOAT (min_height),
                              CLUTTER_UNITS_TO_FLOAT (natural_width),
                              CLUTTER_UNITS_TO_FLOAT (natural_height));
}
%%
override clutter_actor_get_preferred_width kwargs
static PyObject *
_wrap_clutter_actor_get_preferred_width (PyGObject *self,
                                         PyObject  *args,
                                         PyObject  *kwargs)
{
        static char *kwlist[] = { "for_height", NULL };
        double for_height = 0;
        ClutterUnit min_width, natural_width;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "d:ClutterActor.get_preferred_width", kwlist,
                                          &for_height)) {
                return NULL;
        }

        min_width = natural_width = 0;
        clutter_actor_get_preferred_width (CLUTTER_ACTOR (self->obj),
                                           CLUTTER_UNITS_FROM_FLOAT (for_height),
                                           &min_width,
                                           &natural_width);

        return Py_BuildValue ("(dd)",
                              CLUTTER_UNITS_TO_FLOAT (min_width),
                              CLUTTER_UNITS_TO_FLOAT (natural_width));
}
%%
override ClutterActor__proxy_do_get_preferred_width
static void
_wrap_ClutterActor__proxy_do_get_preferred_width (ClutterActor *self,
                                                  ClutterUnit   for_height,
                                                  ClutterUnit  *min_width_p,
                                                  ClutterUnit  *natural_width_p)
{
        PyGILState_STATE state;
        PyObject *py_self, *py_height, *py_args, *py_method, *py_ret;
        double min_width, natural_width;

        state = pyg_gil_state_ensure ();

        py_self = pygobject_new ((GObject *) self);
        if (!py_self) {
                if (PyErr_Occurred ())
                        PyErr_Print();

                pyg_gil_state_release (state);

                return;
        }

        py_height = PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (for_height));

        py_args = PyTuple_New (1);
        PyTuple_SET_ITEM (py_args, 0, py_height);

        py_method = PyObject_GetAttrString (py_self, "do_get_preferred_width");
        if (!py_method) {
                if (PyErr_Occurred ())
                        PyErr_Print ();

                Py_DECREF (py_args);
                Py_DECREF (py_self);

                pyg_gil_state_release (state);

                return;
        }

        py_ret = PyObject_CallObject (py_method, py_args);
        if (!py_ret) {
                PyErr_Print ();

                Py_XDECREF (py_ret);
                Py_DECREF (py_method);
                Py_DECREF (py_args);
                Py_DECREF (py_self);
                
                pyg_gil_state_release (state);
                
                return;
        }

        if (!PyArg_ParseTuple (py_ret, "dd", &min_width, &natural_width)) {
                PyErr_Print ();

                if (min_width_p)
                  *min_width_p = 0;

                if (natural_width_p)
                  *natural_width_p = 0;
        }
        else {
                if (min_width_p)
                  *min_width_p = CLUTTER_UNITS_FROM_FLOAT (min_width);

                if (natural_width_p)
                  *natural_width_p = CLUTTER_UNITS_FROM_FLOAT (natural_width);
        }

        Py_DECREF (py_self);
        Py_DECREF (py_args);
        Py_DECREF (py_method);
        Py_DECREF (py_ret);

        pyg_gil_state_release (state);
}
%%
override ClutterActor__do_get_preferred_width kwargs
static PyObject *
_wrap_ClutterActor__do_get_preferred_width (PyObject *cls,
                                            PyObject *args,
                                            PyObject *kwargs)
{
        ClutterActorClass *klass;
        static char *kwlist[] = { "self", "for_height", NULL };
        PyGObject *self;
        double for_height = 0;
        ClutterUnit min_width = 0, natural_width = 0;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O!d:ClutterActor.do_get_preferred_width",
                                          kwlist,
                                          &PyClutterActor_Type, &self,
                                          &for_height))
                return NULL;

        klass = g_type_class_ref (pyg_type_from_object (cls));
        if (CLUTTER_ACTOR_CLASS (klass)->get_preferred_width) {
                ClutterActor *actor = CLUTTER_ACTOR (self->obj);
                ClutterUnit height = CLUTTER_UNITS_FROM_FLOAT (for_height);

                CLUTTER_ACTOR_CLASS (klass)->get_preferred_width (actor,
                                                                  height,
                                                                  &min_width,
                                                                  &natural_width);
        }
        else {
                PyErr_SetString (PyExc_NotImplementedError,
                                 "virtual method ClutterActor.get_preferred_width "
                                 "not implemented");
                g_type_class_unref (klass);
                return NULL;
        }

        g_type_class_unref (klass);

        return Py_BuildValue ("(dd)",
                              CLUTTER_UNITS_TO_FLOAT (min_width),
                              CLUTTER_UNITS_TO_FLOAT (natural_width));
}
%%
override clutter_actor_get_preferred_height kwargs
static PyObject *
_wrap_clutter_actor_get_preferred_height (PyGObject *self,
                                          PyObject  *args,
                                          PyObject  *kwargs)
{
        static char *kwlist[] = { "for_width", NULL };
        double for_width = 0;
        ClutterUnit min_height, natural_height;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "d:ClutterActor.get_preferred_height", kwlist,
                                          &for_width)) {
                return NULL;
        }

        min_height = natural_height = 0;
        clutter_actor_get_preferred_height (CLUTTER_ACTOR (self->obj),
                                            CLUTTER_UNITS_FROM_FLOAT (for_width),
                                            &min_height,
                                            &natural_height);

        return Py_BuildValue ("(dd)",
                              CLUTTER_UNITS_TO_FLOAT (min_height),
                              CLUTTER_UNITS_TO_FLOAT (natural_height));
}
%%
override ClutterActor__proxy_do_get_preferred_height
static void
_wrap_ClutterActor__proxy_do_get_preferred_height (ClutterActor *self,
                                                   ClutterUnit   for_width,
                                                   ClutterUnit  *min_height_p,
                                                   ClutterUnit  *natural_height_p)
{
        PyGILState_STATE state;
        PyObject *py_self, *py_width, *py_args, *py_method, *py_ret;
        double min_height, natural_height;

        state = pyg_gil_state_ensure ();

        py_self = pygobject_new ((GObject *) self);
        if (!py_self) {
                if (PyErr_Occurred ())
                        PyErr_Print();

                pyg_gil_state_release (state);

                return;
        }

        py_width = PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (for_width));

        py_args = PyTuple_New (1);
        PyTuple_SET_ITEM (py_args, 0, py_width);

        py_method = PyObject_GetAttrString (py_self, "do_get_preferred_height");
        if (!py_method) {
                if (PyErr_Occurred ())
                        PyErr_Print ();

                Py_DECREF (py_args);
                Py_DECREF (py_self);

                pyg_gil_state_release (state);

                return;
        }

        py_ret = PyObject_CallObject (py_method, py_args);
        if (!py_ret) {
                PyErr_Print ();

                Py_XDECREF (py_ret);
                Py_DECREF (py_method);
                Py_DECREF (py_args);
                Py_DECREF (py_self);
                
                pyg_gil_state_release (state);
                
                return;
        }

        if (!PyArg_ParseTuple (py_ret, "dd", &min_height, &natural_height)) {
                PyErr_Print ();

                if (min_height_p)
                  *min_height_p = 0;

                if (natural_height_p)
                  *natural_height_p = 0;
        }
        else {
                if (min_height_p)
                  *min_height_p = CLUTTER_UNITS_FROM_FLOAT (min_height);

                if (natural_height_p)
                  *natural_height_p = CLUTTER_UNITS_FROM_FLOAT (natural_height);
        }

        Py_DECREF (py_self);
        Py_DECREF (py_args);
        Py_DECREF (py_method);
        Py_DECREF (py_ret);

        pyg_gil_state_release (state);
}
%%
override ClutterActor__do_get_preferred_height kwargs
static PyObject *
_wrap_ClutterActor__do_get_preferred_height (PyObject *cls,
                                             PyObject *args,
                                             PyObject *kwargs)
{
        ClutterActorClass *klass;
        static char *kwlist[] = { "self", "for_width", NULL };
        PyGObject *self;
        double for_width = 0;
        ClutterUnit min_height = 0, natural_height = 0;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O!d:ClutterActor.do_get_preferred_height",
                                          kwlist,
                                          &PyClutterActor_Type, &self,
                                          &for_width))
                return NULL;

        klass = g_type_class_ref (pyg_type_from_object (cls));
        if (CLUTTER_ACTOR_CLASS (klass)->get_preferred_height) {
                ClutterActor *actor = CLUTTER_ACTOR (self->obj);
                ClutterUnit width = CLUTTER_UNITS_FROM_FLOAT (for_width);

                CLUTTER_ACTOR_CLASS (klass)->get_preferred_height (actor,
                                                                   width,
                                                                   &min_height,
                                                                   &natural_height);
        }
        else {
                PyErr_SetString (PyExc_NotImplementedError,
                                 "virtual method ClutterActor.get_preferred_height "
                                 "not implemented");
                g_type_class_unref (klass);
                return NULL;
        }

        g_type_class_unref (klass);

        return Py_BuildValue ("(dd)",
                              CLUTTER_UNITS_TO_FLOAT (min_height),
                              CLUTTER_UNITS_TO_FLOAT (natural_height));
}
%%
override clutter_actor_get_anchor_point noargs
static PyObject *
_wrap_clutter_actor_get_anchor_point (PyGObject *self)
{
  gint anchor_x, anchor_y;

  anchor_x = anchor_y = 0;
  clutter_actor_get_anchor_point (CLUTTER_ACTOR (self->obj),
                                  &anchor_x, &anchor_y);

  return Py_BuildValue ("(ii)", anchor_x, anchor_y);
}
%%
override clutter_actor_set_anchor_pointu kwargs
static PyObject *
_wrap_clutter_actor_set_anchor_pointu (PyGObject *self,
                                       PyObject  *args,
                                       PyObject  *kwargs)
{
        static char *kwlist[] = { "anchor_x", "anchor_y", NULL };
        double anchor_x, anchor_y;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "dd:ClutterActor.set_anchor_pointu",
                                          kwlist,
                                          &anchor_x,
                                          &anchor_y)) {
                return NULL;
        }

        clutter_actor_set_anchor_pointu (CLUTTER_ACTOR (self->obj),
                                         CLUTTER_UNITS_FROM_FLOAT (anchor_x),
                                         CLUTTER_UNITS_FROM_FLOAT (anchor_y));

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_actor_move_anchor_pointu kwargs
static PyObject *
_wrap_clutter_actor_move_anchor_pointu (PyGObject *self,
                                        PyObject  *args,
                                        PyObject  *kwargs)
{
        static char *kwlist[] = { "anchor_x", "anchor_y", NULL };
        double anchor_x, anchor_y;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "dd:ClutterActor.move_anchor_pointu",
                                          kwlist,
                                          &anchor_x,
                                          &anchor_y)) {
                return NULL;
        }

        clutter_actor_move_anchor_pointu (CLUTTER_ACTOR (self->obj),
                                          CLUTTER_UNITS_FROM_FLOAT (anchor_x),
                                          CLUTTER_UNITS_FROM_FLOAT (anchor_y));

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_actor_get_anchor_pointu noargs
static PyObject *
_wrap_clutter_actor_get_anchor_pointu (PyGObject *self)
{
  ClutterUnit anchor_x, anchor_y;

  anchor_x = anchor_y = 0;
  clutter_actor_get_anchor_pointu (CLUTTER_ACTOR (self->obj),
                                   &anchor_x, &anchor_y);

  return Py_BuildValue ("(dd)",
                        CLUTTER_UNITS_TO_FLOAT (anchor_x),
                        CLUTTER_UNITS_TO_FLOAT (anchor_y));
}
%%
override clutter_actor_move_byu kwargs
static PyObject *
_wrap_clutter_actor_move_byu (PyGObject *self,
                              PyObject  *args,
                              PyObject  *kwargs)
{
        static char *kwlist[] = { "dx", "dy", NULL };
        double dx, dy;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "dd:ClutterActor.move_byu",
                                          kwlist,
                                          &dx,
                                          &dy)) {
                return NULL;
        }

        clutter_actor_move_byu (CLUTTER_ACTOR (self->obj),
                                CLUTTER_UNITS_FROM_FLOAT (dx),
                                CLUTTER_UNITS_FROM_FLOAT (dy));

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_actor_set_depthu kwargs
static PyObject *
_wrap_clutter_actor_set_depthu (PyGObject *self,
                                PyObject  *args,
                                PyObject  *kwargs)
{
        static char *kwlist[] = { "depth", NULL };
        double depth;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "d:ClutterActor.move_byu",
                                          kwlist,
                                          &depth)) {
                return NULL;
        }

        clutter_actor_set_depthu (CLUTTER_ACTOR (self->obj),
                                  CLUTTER_UNITS_FROM_FLOAT (depth));

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_actor_get_depthu noargs
static PyObject *
_wrap_clutter_actor_get_depthu (PyGObject *self)
{
        ClutterUnit depth;

        depth = clutter_actor_get_depthu (CLUTTER_ACTOR (self->obj));

        return PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (depth));
}
%%
override clutter_actor_get_relative_vertices
static PyObject *
_wrap_clutter_actor_get_relative_vertices (PyGObject *self, PyObject *args)
{
        PyObject *pyvertices, *pyancestor;
        ClutterActor *ancestor;
        ClutterVertex vertices[4];
        int i;

        pyancestor = PyTuple_GetItem (args, 0);
        if (!pyancestor || pyancestor == Py_None)
                ancestor = NULL;
        else if (pygobject_check (pyancestor, &PyClutterActor_Type))
                ancestor = CLUTTER_ACTOR (pygobject_get (pyancestor));
        else {
                PyErr_SetString (PyExc_TypeError,
                                 "first argument must either be None or"
                                 "a clutter.Actor");
                return NULL;
        }

        ancestor = CLUTTER_ACTOR (pygobject_get (pyancestor));

        clutter_actor_get_relative_vertices (CLUTTER_ACTOR (self->obj),
                                             ancestor,
                                             vertices);

        pyvertices = PyTuple_New (4);
        for (i = 0; i < 4; i++) {
                PyObject *pyvertex;

                pyvertex = pyg_boxed_new (CLUTTER_TYPE_VERTEX,
                                          &vertices[i],
                                          TRUE, TRUE);
                PyTuple_SetItem (pyvertices, i, pyvertex);
                Py_XDECREF (pyvertex);
        }

        return pyvertices;
}
%%
override clutter_actor_get_widthu noargs
static PyObject *
_wrap_clutter_actor_get_widthu (PyGObject *self)
{
    ClutterUnit ret;

    ret = clutter_actor_get_widthu (CLUTTER_ACTOR (self->obj));

    return PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (ret));
}
%%
override clutter_actor_get_heightu noargs
static PyObject *
_wrap_clutter_actor_get_heightu (PyGObject *self)
{
    ClutterUnit ret;

    ret = clutter_actor_get_heightu (CLUTTER_ACTOR (self->obj));

    return PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (ret));
}
%%
override clutter_actor_set_widthu kwargs
static PyObject *
_wrap_clutter_actor_set_widthu (PyGObject *self,
                                PyObject  *args,
                                PyObject  *kwargs)
{
    static char *kwlist[] = { "width", NULL };
    double width;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:ClutterActor.set_widthu", kwlist, &width))
        return NULL;

    clutter_actor_set_widthu (CLUTTER_ACTOR (self->obj),
                              CLUTTER_UNITS_FROM_FLOAT (width));

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override clutter_actor_set_heightu kwargs
static PyObject *
_wrap_clutter_actor_set_heightu (PyGObject *self,
                                 PyObject  *args,
                                 PyObject  *kwargs)
{
    static char *kwlist[] = { "height", NULL };
    double height;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:ClutterActor.set_heightu", kwlist, &height))
        return NULL;

    clutter_actor_set_heightu (CLUTTER_ACTOR(self->obj),
                               CLUTTER_UNITS_FROM_FLOAT (height));

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override clutter_actor_get_xu noargs
static PyObject *
_wrap_clutter_actor_get_xu (PyGObject *self)
{
    ClutterUnit ret;

    ret = clutter_actor_get_xu (CLUTTER_ACTOR (self->obj));

    return PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (ret));
}
%%
override clutter_actor_get_yu noargs
static PyObject *
_wrap_clutter_actor_get_yu (PyGObject *self)
{
    ClutterUnit ret;

    ret = clutter_actor_get_yu (CLUTTER_ACTOR (self->obj));

    return PyFloat_FromDouble (CLUTTER_UNITS_TO_FLOAT (ret));
}
%%
override clutter_actor_set_xu kwargs
static PyObject *
_wrap_clutter_actor_set_xu (PyGObject *self,
                            PyObject  *args,
                            PyObject  *kwargs)
{
    static char *kwlist[] = { "x", NULL };
    double x;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"d:ClutterActor.set_xu", kwlist, &x))
        return NULL;

    clutter_actor_set_xu (CLUTTER_ACTOR (self->obj),
                          CLUTTER_UNITS_FROM_FLOAT (x));

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override clutter_actor_set_yu kwargs
static PyObject *
_wrap_clutter_actor_set_yu (PyGObject *self,
                            PyObject  *args,
                            PyObject  *kwargs)
{
    static char *kwlist[] = { "y", NULL };
    double y;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"y:ClutterActor.set_yu", kwlist, &y))
        return NULL;

    clutter_actor_set_yu (CLUTTER_ACTOR (self->obj),
                          CLUTTER_UNITS_FROM_FLOAT (y));

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override clutter_actor_raise kwargs
static PyObject *
_wrap_clutter_actor_raise (PyGObject *self,
                           PyObject  *args,
                           PyObject  *kwargs)
{
    static char *kwlist[] = { "above", NULL };
    PyObject *py_above = NULL;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|O:ClutterActor.raise", kwlist, &py_above))
        return NULL;

    if (py_above == NULL || py_above == Py_None)
        clutter_actor_raise (CLUTTER_ACTOR (self->obj), NULL);
    else if (py_above && pygobject_check (py_above, &PyClutterActor_Type)) {
        ClutterActor *actor;

        actor = CLUTTER_ACTOR (pygobject_get (py_above));
        clutter_actor_raise (CLUTTER_ACTOR (self->obj), actor);
    }
    else {
        PyErr_SetString (PyExc_TypeError, "argument must be either an actor or None");
        return NULL;
    }

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override clutter_actor_lower kwargs
static PyObject *
_wrap_clutter_actor_lower (PyGObject *self,
                           PyObject  *args,
                           PyObject  *kwargs)
{
    static char *kwlist[] = { "below", NULL };
    PyObject *py_below = NULL;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs, "|O:ClutterActor.lower", kwlist, &py_below))
        return NULL;

    if (py_below == NULL || py_below == Py_None)
        clutter_actor_lower (CLUTTER_ACTOR (self->obj), NULL);
    else if (py_below && pygobject_check (py_below, &PyClutterActor_Type)) {
        ClutterActor *actor;

        actor = CLUTTER_ACTOR (pygobject_get (py_below));
        clutter_actor_raise (CLUTTER_ACTOR (self->obj), actor);
    }
    else {
        PyErr_SetString (PyExc_TypeError, "argument must be either an actor or None");
        return NULL;
    }

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override clutter_actor_apply_transform_to_point kwargs
static PyObject *
_wrap_clutter_actor_apply_transform_to_point (PyGObject *self,
                                              PyObject  *args,
                                              PyObject  *kwargs)
{
    static char *kwlist[] = { "point", NULL };
    PyObject *py_point;
    ClutterVertex *point = NULL;
    ClutterVertex retval = { 0, };

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,"O:ClutterActor.apply_transform_to_point", kwlist, &py_point))
        return NULL;

    if (pyg_boxed_check (py_point, CLUTTER_TYPE_VERTEX))
        point = pyg_boxed_get (py_point, ClutterVertex);
    else {
        PyErr_SetString (PyExc_TypeError, "point should be a clutter.Vertex");
        return NULL;
    }

    clutter_actor_apply_transform_to_point (CLUTTER_ACTOR (self->obj), point, &retval);

    return pyg_boxed_new (CLUTTER_TYPE_VERTEX, &retval, TRUE, TRUE);
}
%%
override clutter_actor_apply_relative_transform_to_point kwargs
static PyObject *
_wrap_clutter_actor_apply_relative_transform_to_point (PyGObject *self,
                                                       PyObject  *args,
                                                       PyObject  *kwargs)
{
    static char *kwlist[] = { "ancestor", "point", NULL };
    PyObject *py_ancestor = NULL;
    PyObject *py_point;
    ClutterActor *ancestor = NULL;
    ClutterVertex *point = NULL;
    ClutterVertex retval = { 0, };

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,"OO:ClutterActor.apply_transform_to_point", kwlist, &py_ancestor, &py_point))
        return NULL;

    if (py_ancestor == NULL || py_ancestor == Py_None)
        ancestor = NULL;
    else if (py_ancestor && pygobject_check (py_ancestor, &PyClutterActor_Type))
        ancestor = CLUTTER_ACTOR (pygobject_get (py_ancestor));
    else {
        PyErr_SetString (PyExc_TypeError, "ancestor should be a clutter.Actor or None");
        return NULL;
    }

    if (pyg_boxed_check (py_point, CLUTTER_TYPE_VERTEX))
        point = pyg_boxed_get (py_point, ClutterVertex);
    else {
        PyErr_SetString (PyExc_TypeError, "point should be a clutter.Vertex");
        return NULL;
    }

    clutter_actor_apply_relative_transform_to_point (CLUTTER_ACTOR (self->obj),
                                                     ancestor,
                                                     point, &retval);

    return pyg_boxed_new (CLUTTER_TYPE_VERTEX, &retval, TRUE, TRUE);
}
