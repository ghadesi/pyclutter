%%
ignore
  clutter_actor_transform_stage_point
%%
override clutter_actor_get_geometry noargs
static PyObject *
_wrap_clutter_actor_get_geometry (PyGObject *self)
{
        ClutterGeometry geom = { 0, };

        clutter_actor_get_geometry (CLUTTER_ACTOR (self->obj), &geom);

        return Py_BuildValue ("(iiii)",
                              geom.x, geom.y, geom.width, geom.height);
}
%%
override clutter_actor_set_geometry kwargs
static PyObject *
_wrap_clutter_actor_set_geometry (PyGObject *self,
                                  PyObject  *args,
                                  PyObject  *kwargs)
{
        static char *kwlist[] = { "geometry", NULL };
        PyObject *py_geom;
        ClutterGeometry geom;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O:ClutterActor.set_geometry", kwlist,
                                          &py_geom)) {
                return NULL;
        }

        if (!pyclutter_geometry_from_pyobject (py_geom, &geom)) {
                PyErr_Clear ();
                PyErr_SetString (PyExc_TypeError,
                                 "color must be a ClutterGeometry or 4-tuple");
                return NULL;
        }

        clutter_actor_set_geometry (CLUTTER_ACTOR (self->obj), &geom);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_actor_get_coords noargs
static PyObject *
_wrap_clutter_actor_get_coords (PyGObject *self)
{
	gint x1, y1;
	gint x2, y2;

	clutter_actor_get_coords (CLUTTER_ACTOR (self->obj),
				  &x1, &y1,
				  &x2, &y2);
	return Py_BuildValue("(iiii)", x1, y1, x2, y2);
}
%%
override clutter_actor_get_abs_position noargs
static PyObject *
_wrap_clutter_actor_get_abs_position (PyGObject *self)
{
	gint pos_x, pos_y;

	clutter_actor_get_abs_position (CLUTTER_ACTOR (self->obj),
					&pos_x,
					&pos_y);
	return Py_BuildValue("(ii)", pos_x, pos_y);
}
%%
override clutter_actor_get_abs_size noargs
static PyObject *
_wrap_clutter_actor_get_abs_size (PyGObject *self)
{
        guint width, height;

        clutter_actor_get_abs_size (CLUTTER_ACTOR (self->obj),
                                    &width,
                                    &height);
        return Py_BuildValue ("(ii)", width, height);
}
%%
override clutter_actor_get_size noargs
static PyObject *
_wrap_clutter_actor_get_size (PyGObject *self)
{
        guint width, height;

        clutter_actor_get_size (CLUTTER_ACTOR (self->obj),
                                &width,
                                &height);
        return Py_BuildValue ("(ii)", width, height);
}
%%
override clutter_actor_get_position noargs
static PyObject *
_wrap_clutter_actor_get_position (PyGObject *self)
{
        gint x, y;

        clutter_actor_get_position (CLUTTER_ACTOR (self->obj), &x, &y);

        return Py_BuildValue ("(ii)", x, y);
}
%%
override clutter_actor_get_scale noargs
static PyObject *
_wrap_clutter_actor_get_scale (PyGObject *self)
{
        gdouble scale_x, scale_y;

        clutter_actor_get_scale (CLUTTER_ACTOR (self->obj),
                                 &scale_x,
                                 &scale_y);
        return Py_BuildValue ("(ff)", scale_x, scale_y);
}
%%
override clutter_actor_get_vertices noargs
static PyObject *
_wrap_clutter_actor_get_vertices (PyGObject *self)
{
        ClutterVertex vertices[4];
        PyObject *pyvertices;
        int i;

        clutter_actor_get_vertices (CLUTTER_ACTOR (self->obj), vertices);

        pyvertices = PyTuple_New (4);
        for (i = 0; i < 4; i++) {
                PyObject *pyvertex;

                pyvertex = pyg_boxed_new (CLUTTER_TYPE_VERTEX, &vertices[i],
                                          TRUE, TRUE);
                PyTuple_SetItem (pyvertices, i, pyvertex);
                Py_XDECREF (pyvertex);
        }

        return pyvertices;
}
%%
override clutter_actor_set_rotation kwargs
static PyObject *
_wrap_clutter_actor_set_rotation (PyGObject *self,
                                  PyObject  *args,
                                  PyObject  *kwargs)
{
        static char *kwlist[] = { "axis", "angle", "x", "y", "z", NULL };
        int axis;
        double angle;
        int x, y, z;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "idiii:ClutterActor.set_rotation",
                                          kwlist,
                                          &axis,
                                          &angle,
                                          &x, &y, &z)) {
                return NULL;
        }

        clutter_actor_set_rotation (CLUTTER_ACTOR (self->obj), axis,
                                    angle,
                                    x, y, z);

        Py_INCREF (Py_None);
        return Py_None;
}
%%
override clutter_actor_get_rotation kwargs
static PyObject *
_wrap_clutter_actor_get_rotation (PyGObject *self,
                                  PyObject  *args,
                                  PyObject  *kwargs)
{
        static char *kwlist[] = { "axis", NULL };
        int axis;
        gint center_x, center_y, center_z;
        gdouble angle;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "i:ClutterActor.get_rotation", kwlist,
                                          &axis)) {
                return NULL;
        }

        angle = clutter_actor_get_rotation (CLUTTER_ACTOR (self->obj), axis,
                                            &center_x,
                                            &center_y,
                                            &center_z);

        return Py_BuildValue ("(diii)",
                              angle,
                              center_x, center_y, center_z);
}
%%
override clutter_actor_get_clip noargs
static PyObject *
_wrap_clutter_actor_get_clip (PyGObject *self)
{
	gint xoff, yoff;
	gint width, height;

	clutter_actor_get_clip (CLUTTER_ACTOR (self->obj),
                                &xoff, &yoff,
                                &width, &height);
	return Py_BuildValue("(iiii)", xoff, yoff, width, height);
}
%%
override clutter_actor_query_coords noargs
static PyObject *
_wrap_clutter_actor_query_coords (PyGObject *self)
{
        ClutterActorBox box;

        clutter_actor_query_coords (CLUTTER_ACTOR (self), &box);

        return Py_BuildValue ("(iiii)", box.x1, box.y1, box.x2, box.y2);
}
%%
override ClutterActor__proxy_do_query_coords
static void
_wrap_ClutterActor__proxy_do_query_coords (ClutterActor    *self,
                                           ClutterActorBox *box)
{
        PyGILState_STATE state;
        PyObject *py_self, *py_box, *py_args, *py_method, *py_ret;
        gint32 x1, y1, x2, y2;

        state = pyg_gil_state_ensure ();

        py_self = pygobject_new ((GObject *) self);
        if (!py_self) {
                if (PyErr_Occurred ())
                        PyErr_Print();

                pyg_gil_state_release (state);

                return;
        }

        py_box = pyg_boxed_new (CLUTTER_TYPE_ACTOR_BOX, box, FALSE, FALSE);

        py_args = PyTuple_New (1);
        PyTuple_SET_ITEM (py_args, 0, py_box);

        py_method = PyObject_GetAttrString (py_self, "do_query_coords");
        if (!py_method) {
                if (PyErr_Occurred ())
                        PyErr_Print ();

                Py_DECREF (py_args);
                Py_DECREF (py_self);

                pyg_gil_state_release (state);

                return;
        }

        py_ret = PyObject_CallObject (py_method, py_args);
        if (!py_ret) {
                PyErr_Print ();

                Py_XDECREF (py_ret);
                Py_DECREF (py_method);
                Py_DECREF (py_args);
                Py_DECREF (py_self);
                
                pyg_gil_state_release (state);
                
                return;
        }

        if (!PyArg_ParseTuple (py_ret, "iiii", &x1, &y1, &x2, &y2)) {
                PyErr_Print ();

                Py_DECREF (py_ret);
                Py_DECREF (py_method);
                Py_DECREF (py_args);
                Py_DECREF (py_self);
                
                pyg_gil_state_release (state);
                
                return;
        }
        else {
                if (box) {
                        box->x1 = x1;
                        box->y1 = y1;
                        box->x2 = x2;
                        box->y2 = y2;
                }
        }

        Py_DECREF (py_self);
        Py_DECREF (py_args);
        Py_DECREF (py_method);
        Py_DECREF (py_ret);

        pyg_gil_state_release (state);
}
%%
override ClutterActor__do_query_coords kwargs
static PyObject *
_wrap_ClutterActor__do_query_coords (PyObject *cls,
                                     PyObject *args,
                                     PyObject *kwargs)
{
        ClutterActorClass *klass;
        static char *kwlist[] = { "self", "box", NULL };
        PyGObject *self;
        PyObject *py_box;
        ClutterActorBox *box;

        if (!PyArg_ParseTupleAndKeywords (args, kwargs,
                                          "O!O:ClutterActor.query_coords",
                                          kwlist,
                                          &PyClutterActor_Type,
                                          &self, &py_box))
                return NULL;

        if (pyg_boxed_check (py_box, CLUTTER_TYPE_ACTOR_BOX))
                box = pyg_boxed_get (py_box, ClutterActorBox);
        else {
                PyErr_SetString (PyExc_TypeError,
                                 "box should be a ClutterActorBox");
                return NULL;
        }

        klass = g_type_class_ref (pyg_type_from_object (cls));
        if (CLUTTER_ACTOR_CLASS (klass)->query_coords) {
                ClutterActor *actor = CLUTTER_ACTOR (self->obj);

                CLUTTER_ACTOR_CLASS (klass)->query_coords (actor, box);
        }
        else {
                PyErr_SetString (PyExc_NotImplementedError,
                                 "virtual method ClutterActor.query_coords "
                                 "not implemented");
                g_type_class_unref (klass);
                return NULL;
        }

        g_type_class_unref (klass);

        /* "box" is an in-out parameter */
        return Py_BuildValue ("(iiii)", box->x1, box->y1, box->x2, box->y2);
}
%%
override clutter_actor_get_anchor_point noargs
static PyObject *
_wrap_clutter_actor_get_anchor_point (PyGObject *self)
{
  gint anchor_x, anchor_y;

  anchor_x = anchor_y = 0;
  clutter_actor_get_anchor_point (CLUTTER_ACTOR (self->obj),
                                  &anchor_x, &anchor_y);

  return Py_BuildValue ("(ii)", anchor_x, anchor_y);
}
%%
override clutter_actor_get_relative_vertices
static PyObject *
_wrap_clutter_actor_get_relative_vertices (PyGObject *self, PyObject *args)
{
        PyObject *pyvertices, *pyancestor;
        ClutterActor *ancestor;
        ClutterVertex vertices[4];
        int i;

        pyancestor = PyTuple_GetItem (args, 0);
        if (!pyancestor || pyancestor == Py_None)
                ancestor = NULL;
        else if (pygobject_check (pyancestor, &PyClutterActor_Type))
                ancestor = CLUTTER_ACTOR (pygobject_get (pyancestor));
        else {
                PyErr_SetString (PyExc_TypeError,
                                 "first argument must either be None or"
                                 "a clutter.Actor");
                return NULL;
        }

        ancestor = CLUTTER_ACTOR (pygobject_get (pyancestor));

        clutter_actor_get_relative_vertices (CLUTTER_ACTOR (self->obj),
                                             ancestor,
                                             vertices);

        pyvertices = PyTuple_New (4);
        for (i = 0; i < 4; i++) {
                PyObject *pyvertex;

                pyvertex = pyg_boxed_new (CLUTTER_TYPE_VERTEX,
                                          &vertices[i],
                                          TRUE, TRUE);
                PyTuple_SetItem (pyvertices, i, pyvertex);
                Py_XDECREF (pyvertex);
        }

        return pyvertices;
}
%%
