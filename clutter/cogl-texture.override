%%
override cogl_texture_new_from_file kwargs
static PyObject *
_wrap_cogl_texture_new_from_file (PyObject *self,
                                  PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "filename", "flags", "internal_format", NULL };
    CoglTextureFlags flags;
    CoglPixelFormat internal_format;
    GError *error = NULL;
    char *filename;
    PyObject *py_flags = NULL;
    PyObject *py_internal_format = NULL;
    CoglHandle ret = COGL_INVALID_HANDLE;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,"sOO:texture_new_from_file", kwlist, &filename, &py_flags, &py_internal_format))
        return NULL;

    if (pyg_enum_get_value (COGL_TYPE_TEXTURE_FLAGS, py_flags, (gpointer)&flags))
        return NULL;

    if (pyg_enum_get_value (COGL_TYPE_PIXEL_FORMAT, py_internal_format, (gpointer)&internal_format))
        return NULL;

    ret = cogl_texture_new_from_file (filename,
                                      flags,
                                      internal_format,
                                      &error);

    if (pyg_error_check (&error))
        return NULL;

    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new (COGL_TYPE_HANDLE, ret, TRUE, TRUE);
}
%%
override cogl_texture_new_from_data kwargs
static PyObject *
_wrap_cogl_texture_new_from_data (PyObject *self,
                                  PyObject *args,
                                  PyObject *kwargs)
{
    static char *kwlist[] = { "width", "height", "flags", "format", "internal_format", "rowstride", "data", NULL };
    PyObject *py_width = NULL, *py_height = NULL, *py_flags = NULL, *py_format = NULL, *py_internal_format = NULL, *py_rowstride = NULL;
    CoglTextureFlags flags;
    CoglPixelFormat format, internal_format;
    guint width = 0, height = 0, rowstride = 0;
    guchar *data;
    CoglHandle ret = COGL_INVALID_HANDLE;
    Py_ssize_t data_len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,"OOOOOOs#:texture_new_from_data", kwlist, &py_width, &py_height, &py_flags, &py_format, &py_internal_format, &py_rowstride, &data, &data_len))
        return NULL;

    if (py_width) {
        if (PyLong_Check (py_width))
            width = PyLong_AsUnsignedLong (py_width);
        else if (PyInt_Check (py_width))
            width = PyInt_AsLong (py_width);
        else
            PyErr_SetString (PyExc_TypeError, "Parameter 'width' must be an int or a long");

        if (PyErr_Occurred ())
            return NULL;
    }

    if (py_height) {
        if (PyLong_Check (py_height))
            height = PyLong_AsUnsignedLong (py_height);
        else if (PyInt_Check (py_height))
            height = PyInt_AsLong (py_height);
        else
            PyErr_SetString (PyExc_TypeError, "Parameter 'height' must be an int or a long");

        if (PyErr_Occurred ())
            return NULL;
    }

    if (pyg_enum_get_value (COGL_TYPE_TEXTURE_FLAGS, py_flags, (gpointer)&flags))
        return NULL;

    if (pyg_enum_get_value (COGL_TYPE_PIXEL_FORMAT, py_format, (gpointer)&format))
        return NULL;

    if (pyg_enum_get_value (COGL_TYPE_PIXEL_FORMAT, py_internal_format, (gpointer)&internal_format))
        return NULL;

    if (py_rowstride) {
        if (PyLong_Check (py_rowstride))
            rowstride = PyLong_AsUnsignedLong (py_rowstride);
        else if (PyInt_Check (py_rowstride))
            rowstride = PyInt_AsLong (py_rowstride);
        else
            PyErr_SetString (PyExc_TypeError, "Parameter 'rowstride' must be an int or a long");

        if (PyErr_Occurred ())
            return NULL;
    }

    ret = cogl_texture_new_from_data (width, height,
                                      flags,
                                      format, internal_format,
                                      rowstride,
                                      data);

    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new (COGL_TYPE_HANDLE, ret, TRUE, TRUE);
}
%%
override cogl_texture_new_from_foreign kwargs
static PyObject *
_wrap_cogl_texture_new_from_foreign (PyObject *self,
                                     PyObject *args,
                                     PyObject *kwargs)
{
    static char *kwlist[] = { "gl_handle", "gl_target", "width", "height", "x_pot_waste", "y_pot_waste", "format", NULL };
    PyObject *py_gl_handle = NULL, *py_width = NULL, *py_height = NULL, *py_x_pot_waste = NULL, *py_y_pot_waste = NULL, *py_format = NULL;
    int gl_target;
    CoglPixelFormat format;
    guint gl_handle = 0, width = 0, height = 0, x_pot_waste = 0, y_pot_waste = 0;
    CoglHandle ret = COGL_INVALID_HANDLE;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs,"OiOOOOO:texture_new_from_foreign", kwlist, &py_gl_handle, &gl_target, &py_width, &py_height, &py_x_pot_waste, &py_y_pot_waste, &py_format))
        return NULL;

    if (py_gl_handle) {
        if (PyLong_Check (py_gl_handle))
            gl_handle = PyLong_AsUnsignedLong (py_gl_handle);
        else if (PyInt_Check (py_gl_handle))
            gl_handle = PyInt_AsLong (py_gl_handle);
        else
            PyErr_SetString (PyExc_TypeError, "Parameter 'gl_handle' must be an int or a long");

        if (PyErr_Occurred ())
            return NULL;
    }

    if (py_width) {
        if (PyLong_Check (py_width))
            width = PyLong_AsUnsignedLong (py_width);
        else if (PyInt_Check (py_width))
            width = PyInt_AsLong (py_width);
        else
            PyErr_SetString (PyExc_TypeError, "Parameter 'width' must be an int or a long");

        if (PyErr_Occurred ())
            return NULL;
    }

    if (py_height) {
        if (PyLong_Check (py_height))
            height = PyLong_AsUnsignedLong (py_height);
        else if (PyInt_Check (py_height))
            height = PyInt_AsLong (py_height);
        else
            PyErr_SetString (PyExc_TypeError, "Parameter 'height' must be an int or a long");

        if (PyErr_Occurred ())
            return NULL;
    }

    if (py_x_pot_waste) {
        if (PyLong_Check (py_x_pot_waste))
            x_pot_waste = PyLong_AsUnsignedLong (py_x_pot_waste);
        else if (PyInt_Check (py_x_pot_waste))
            x_pot_waste = PyInt_AsLong (py_x_pot_waste);
        else
            PyErr_SetString (PyExc_TypeError, "Parameter 'x_pot_waste' must be an int or a long");

        if (PyErr_Occurred ())
            return NULL;
    }

    if (py_y_pot_waste) {
        if (PyLong_Check (py_y_pot_waste))
            y_pot_waste = PyLong_AsUnsignedLong (py_y_pot_waste);
        else if (PyInt_Check (py_y_pot_waste))
            y_pot_waste = PyInt_AsLong (py_y_pot_waste);
        else
            PyErr_SetString (PyExc_TypeError, "Parameter 'y_pot_waste' must be an int or a long");

        if (PyErr_Occurred ())
            return NULL;
    }

    if (pyg_enum_get_value (COGL_TYPE_PIXEL_FORMAT, py_format, (gpointer)&format))
        return NULL;

    ret = cogl_texture_new_from_foreign (gl_handle, gl_target,
                                         width, height,
                                         x_pot_waste, y_pot_waste,
                                         format);

    /* pyg_boxed_new handles NULL checking */
    return pyg_boxed_new (COGL_TYPE_HANDLE, ret, TRUE, TRUE);
}
%%
override cogl_texture_get_gl_texture noargs
static PyObject *
_wrap_cogl_texture_get_gl_texture (PyObject *self)
{
    CoglHandle hnd = pyg_boxed_get (self, CoglHandle);
    GLuint gl_handle = 0;
    GLenum gl_target = 0;

    if (cogl_is_texture (hnd)) {
        cogl_texture_get_gl_texture (hnd, &gl_handle, &gl_target);

        return Py_BuildValue ("(ii)", gl_handle, gl_target);
    }

    return Py_BuildValue ("()");
}
%%
override cogl_rectangle_with_multitexture_coords kwargs
static PyObject *
_wrap_cogl_rectangle_with_multitexture_coords (PyObject *self,
                                               PyObject *args,
                                               PyObject *kwargs)
{
    static char *kwlist[] = { "x1", "y1", "x2", "y2", "tex_coords", NULL };
    float x1, y1, x2, y2;
    gint tex_coords_len;
    PyObject *py_coords;

    if (!PyArg_ParseTupleAndKeywords (args, kwargs, "ffffO:rectangle_with_multitexture_coords",
                                      kwlist, &x1, &y1, &x2, &y2, &py_coords))
        return NULL;

    if (!PyTuple_Check (py_coords)) {
        PyErr_SetString (PyExc_TypeError, "tex_coords must be a tuple");
        return NULL;
    }

    tex_coords_len = PyTuple_Size (py_coords);
    gfloat tex_coords[tex_coords_len];
    gint i;

    for (i = 0; i < tex_coords_len; i++) {
        tex_coords[i] = PyFloat_AsDouble (PyTuple_GetItem (py_coords, i));
    }

    cogl_rectangle_with_multitexture_coords (x1, y1, x2, y2, tex_coords,
                                             tex_coords_len);

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override cogl_path_polyline
static PyObject *
_wrap_cogl_path_polyline (PyObject *self, PyObject *args)
{
    gint len, i; 
    float *coords;

    len = PyTuple_Size (args);

    coords = g_new0 (float, len * 2);

    for (i = 0; i < len; i++) {
        PyObject *vertex;
        
        vertex = PyTuple_GetItem (args, i);

        if (!PyTuple_Check (vertex) || PyTuple_Size (vertex) != 2) {
            PyErr_SetString (PyExc_TypeError, "Need a tuple of tuples");
            return NULL;
        }

        coords[i] = PyFloat_AsDouble (PyTuple_GetItem (vertex, 0));
        coords[i+1] = PyFloat_AsDouble (PyTuple_GetItem (vertex, 1));
    }

    cogl_path_polyline (coords, len);
    g_free (coords);

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override cogl_path_polygon
static PyObject *
_wrap_cogl_path_polygon (PyObject *self, PyObject *args)
{
    gint len, i; 
    float *coords;

    len = PyTuple_Size (args);

    coords = g_new0 (float, len * 2);

    for (i = 0; i < len; i++) {
        PyObject *vertex;
        
        vertex = PyTuple_GetItem (args, i);
        if (!PyTuple_Check (vertex) || PyTuple_Size (vertex) != 2) {
            PyErr_SetString (PyExc_TypeError, "Need a tuple of tuples");
            return NULL;
        }

        coords[i] = PyFloat_AsDouble (PyTuple_GetItem (vertex, 0));
        coords[i+1] = PyFloat_AsDouble (PyTuple_GetItem (vertex, 1));
    }

    cogl_path_polygon (coords, len);
    g_free (coords);

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override cogl_rectangles
static PyObject *
_wrap_cogl_rectangles (PyObject *self, PyObject *args)
{
    gint len, i; 
    float *coords;

    len = PyTuple_Size (args);

    coords = g_new0 (float, len * 4);

    for (i = 0; i < len; i++) {
        PyObject *vertex;
        
        vertex = PyTuple_GetItem (args, i);
        if (!PyTuple_Check (vertex) || PyTuple_Size (vertex) != 4) {
            PyErr_SetString (PyExc_TypeError, "Need a tuple of tuples");
            return NULL;
        }

        coords[i] = PyFloat_AsDouble (PyTuple_GetItem (vertex, 0));
        coords[i+1] = PyFloat_AsDouble (PyTuple_GetItem (vertex, 1));
        coords[i+2] = PyFloat_AsDouble (PyTuple_GetItem (vertex, 2));
        coords[i+3] = PyFloat_AsDouble (PyTuple_GetItem (vertex, 3));
    }

    cogl_rectangles (coords, len);
    g_free (coords);

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override cogl_rectangles_with_texture_coords
static PyObject *
_wrap_cogl_rectangles_with_texture_coords (PyObject *self, PyObject *args)
{
    gint len, i; 
    float *coords;

    len = PyTuple_Size (args);

    coords = g_new (float, len * 8);

    for (i = 0; i < len; i++) {
        PyObject *vertex;
        
        vertex = PyTuple_GetItem (args, i);
        if (!PyTuple_Check (vertex) || PyTuple_Size (vertex) != 8) {
            PyErr_SetString (PyExc_TypeError, "Need a tuple of tuples");
            return NULL;
        }

        coords[i] = PyFloat_AsDouble (PyTuple_GetItem (vertex, 0));
        coords[i+1] = PyFloat_AsDouble (PyTuple_GetItem (vertex, 1));
        coords[i+2] = PyFloat_AsDouble (PyTuple_GetItem (vertex, 2));
        coords[i+3] = PyFloat_AsDouble (PyTuple_GetItem (vertex, 3));
    }

    cogl_rectangles_with_texture_coords (coords, len);
    g_free (coords);

    Py_INCREF (Py_None);
    return Py_None;
}
%%
override cogl_polygon kwargs
static PyObject *
_wrap_cogl_polygon (PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "vertices", "use_color", NULL };
    PyObject *py_vertices;
    gboolean use_color;
    CoglTextureVertex *vertices = NULL;
    int i, n_vertices;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Oi:cogl.polygon",
                                     kwlist, &py_vertices, &use_color))
        return NULL;

    if (!PyTuple_Check (py_vertices)) {
        PyErr_SetString (PyExc_TypeError, "vertices must be a tuple");
        return NULL;
    }

    n_vertices = PyTuple_Size (py_vertices);
    vertices = g_new (CoglTextureVertex, n_vertices);

    for (i = 0; i < n_vertices; i++) {
        PyObject *py_vertex = PyTuple_GetItem (py_vertices, i);
        PyObject *py_color;

        if (!PyTuple_Check (py_vertex) && 
            (PyTuple_Size (py_vertex) != 5 || PyTuple_Size (py_vertex) != 6)) {
            PyErr_SetString (PyExc_TypeError, "expecting a 5-tuple (x, y, z, tx, ty) "
                                               "or a 6-tuple (x, y, z, tx, ty, color)");
            g_free (vertices);
            return NULL;
        }

        if (!PyArg_ParseTuple (py_vertex, "fffff|O", &(vertices[i].x),
                               &(vertices[i].y), &(vertices[i].z),
                               &(vertices[i].tx), &(vertices[i].ty),
                               &py_color)) {
            g_free (vertices);
            return NULL;
        }

        if (PyTuple_Size (py_vertex) == 6) {
            if (!pycogl_color_from_pyobject (py_color, &(vertices[i].color))) {
                PyErr_SetString (PyExc_TypeError, "expecting a clutter.Color as "
                                                  "the 6th element of the vertex "
                                                  "tuple");
                g_free (vertices);
                return NULL;
            }
        }
    }

    cogl_polygon (vertices, n_vertices, use_color);
    g_free (vertices);

    Py_INCREF (Py_None);
    return Py_None;
}
