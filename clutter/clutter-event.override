%%
ignore
  clutter_event_get_coords
  clutter_event_get_time
  clutter_event_get_state
  clutter_event_get_source
  clutter_event_free
  clutter_event_copy
  clutter_key_event_symbol
  clutter_key_event_code
  clutter_key_event_unicode
  clutter_button_event_button
%%
override clutter_event_get_coords noargs
static PyObject *
_wrap_clutter_event_get_coords (PyObject *self)
{
  ClutterEvent *event = pyg_boxed_get (self, ClutterEvent);
  gint x, y;

  clutter_event_get_coords (event, &x, &y));

  return Py_BuildValue ("(ii)", x, y);
}
%%
override-slot ClutterEvent.tp_setattr
#define CHECK_VALUE_IS_INT(a,v) \
	G_STMT_START{ if (!PyInt_Check ((v))) { \
		PyErr_Format (PyExc_TypeError, "%s must be an int", (a)); \
		return -1; \
	} }G_STMT_END
static int
_wrap_clutter_event_tp_setattr (PyObject *self,
				char     *attr,
				PyObject *value)
{
	ClutterEvent *event;

	if (value == NULL) {
		PyErr_SetString (PyExc_TypeError, "can't delete attributes");
		return -1;
	}

	event = pyg_boxed_get (self, ClutterEvent);

	/* common members */
	if (attr[0] == 't' && !strcmp (attr, "type")) {
		PyErr_SetString (PyExc_AttributeError, "type is not writable");
		return -1;
	}

	switch (event->type) {
		case CLUTTER_NOTHING:
			break;
		case CLUTTER_MOTION:	/* ClutterMotionEvent 	motion */
			if (!strcmp (attr, "time")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->motion.time = PyInt_AsLong (value);
				return 0;
			}
			else if (attr[0] == 'x' && attr[1] == '\0') {
				CHECK_VALUE_IS_INT (attr, value);
				event->motion.x = PyInt_AsLong (value);
				return 0;
			}
			else if (attr[0] == 'y' && attr[1] == '\0') {
				CHECK_VALUE_IS_INT (attr, value);
				event->motion.y = PyInt_AsLong (value);
				return 0;
			}
			else if (!strcmp (attr, "modifier_state")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->motion.modifier_state = PyInt_AsLong (value);
				return 0;
			}
			break;
		case CLUTTER_BUTTON_PRESS:	/* ClutterButtonEvent	button */
		case CLUTTER_BUTTON_RELEASE:
			if (!strcmp (attr, "time")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->button.time = PyInt_AsLong (value);
				return 0;
			}
			else if (attr[0] == 'x' && attr[1] == '\0') {
				CHECK_VALUE_IS_INT (attr, value);
				event->button.x = PyInt_AsLong (value);
				return 0;
			}
			else if (attr[0] == 'y' && attr[1] == '\0') {
				CHECK_VALUE_IS_INT (attr, value);
				event->button.y = PyInt_AsLong (value);
				return 0;
			}
			else if (!strcmp (attr, "modifier_state")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->button.modifier_state = PyInt_AsLong (value);
				return 0;
			}
			else if (!strcmp (attr, "button")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->button.button = PyInt_AsLong (value);
				return 0;
			}
                        else if (!strcmp (attr, "click_count")) {
                                CHECK_VALUE_IS_INT (attr, value);
                                event->button.click_count = PyInt_AsLong (value);
                                return 0;
                        }
			break;
                case CLUTTER_SCROLL:
                        if (!strcmp (attr, "time")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->scroll.time = PyInt_AsLong (value);
				return 0;
			}
			else if (attr[0] == 'x' && attr[1] == '\0') {
				CHECK_VALUE_IS_INT (attr, value);
				event->scroll.x = PyInt_AsLong (value);
				return 0;
			}
			else if (attr[0] == 'y' && attr[1] == '\0') {
				CHECK_VALUE_IS_INT (attr, value);
				event->scroll.y = PyInt_AsLong (value);
				return 0;
			}
			else if (!strcmp (attr, "modifier_state")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->scroll.modifier_state = PyInt_AsLong (value);
				return 0;
			}
			else if (!strcmp (attr, "button")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->scroll.direction = PyInt_AsLong (value);
				return 0;
			}
                        break;
		case CLUTTER_KEY_PRESS: /* ClutterKeyEvent:	key */
		case CLUTTER_KEY_RELEASE:
			if (!strcmp (attr, "time")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->key.time = PyInt_AsLong (value);
				return 0;
			}
			else if (!strcmp (attr, "modifier_state")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->key.modifier_state = PyInt_AsLong (value);
				return 0;
			}
			else if (!strcmp (attr, "keyval")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->key.keyval = PyInt_AsLong (value);
				return 0;
			}
			else if (!strcmp (attr, "hardware_keycode")) {
				CHECK_VALUE_IS_INT (attr, value);
				event->key.hardware_keycode = PyInt_AsLong (value);
				return 0;
			}
                        else if (!strcmp (attr, "unicode_value")) {
                                CHECK_VALUE_IS_INT (attr, value);
                                event->key.unicode_value = PyInt_AsLong (value);
                                return 0;
                        }
			break;
		default:
			break;
	}

#undef CHECK_VALUE_IS_INT
	
        PyErr_SetString (PyExc_AttributeError, "could not write attribute");
	return -1;
}
%%
override-slot ClutterEvent.tp_getattr
PyObject *
_wrap_clutter_event_tp_getattr (PyObject *self,
				char     *attr)
{
	ClutterEvent *event = pyg_boxed_get (self, ClutterEvent);

	switch (event->type) {
		case CLUTTER_NOTHING:
			break;
		case CLUTTER_MOTION: /* ClutterMotionEvent	motion */
			if (!strcmp (attr, "__members__"))
				return Py_BuildValue ("[ssssssss]",
						      "type",
						      "time",
                                                      "flags",
                                                      "stage",
                                                      "source",
						      "modifier_state",
						      "x", "y");
			if (!strcmp (attr, "x"))
				return PyInt_FromLong (event->motion.x);
			if (!strcmp (attr, "y"))
				return PyInt_FromLong (event->motion.y);
			break;
		case CLUTTER_BUTTON_PRESS:
		case CLUTTER_BUTTON_RELEASE:
			if (!strcmp (attr, "__members__"))
				return Py_BuildValue ("[ssssssssss]",
						      "type",
						      "time",
                                                      "flags",
                                                      "stage",
                                                      "source",
						      "modifier_state",
						      "x", "y",
						      "button",
                                                      "click_count");
			if (!strcmp (attr, "x"))
				return PyInt_FromLong (event->button.x);
			if (!strcmp (attr, "y"))
				return PyInt_FromLong (event->button.y);
			if (!strcmp (attr, "button"))
				return PyInt_FromLong (event->button.button);
                        if (!strcmp (attr, "click_count"))
                                return PyInt_FromLong (event->button.click_count);
			break;
                case CLUTTER_SCROLL:
                        if (!strcmp (attr, "__members__"))
				return Py_BuildValue ("[sssssssss]",
						      "type",
						      "time",
                                                      "flags",
                                                      "stage",
                                                      "source",
						      "modifier_state",
						      "x", "y",
						      "direction");
			if (!strcmp (attr, "x"))
				return PyInt_FromLong (event->scroll.x);
			if (!strcmp (attr, "y"))
				return PyInt_FromLong (event->scroll.y);
			if (!strcmp (attr, "direction"))
				return pyg_enum_from_gtype (CLUTTER_TYPE_SCROLL_DIRECTION, event->scroll.direction);
                        break;
		case CLUTTER_KEY_PRESS:
		case CLUTTER_KEY_RELEASE:
			if (!strcmp (attr, "__members__"))
				return Py_BuildValue ("[sssssssss]",
						      "type",
						      "time",
                                                      "flags"
                                                      "stage",
                                                      "source",
						      "modifier_state",
						      "keyval",
						      "hardware_keycode",
                                                      "unicode_value");
			if (!strcmp (attr, "keyval"))
				return PyInt_FromLong (clutter_key_event_symbol ((ClutterKeyEvent *) event));
			if (!strcmp (attr, "hardware_keycode"))
				return PyInt_FromLong (clutter_key_event_code ((ClutterKeyEvent *) event));
                        if (!strcmp (attr, "unicode_value"))
                                return PyInt_FromLong (clutter_key_event_unicode ((ClutterKeyEvent *) event));
			break;
                case CLUTTER_ENTER:
                case CLUTTER_LEAVE:
                        if (!strcmp (attr, "__members__"))
                                return Py_BuildValue ("[ssssssss]",
                                                      "type",
                                                      "time",
                                                      "flags",
                                                      "stage",
                                                      "source",
                                                      "x", "y",
                                                      "related");
			if (!strcmp (attr, "x"))
				return PyInt_FromLong (event->crossing.x);
			if (!strcmp (attr, "y"))
				return PyInt_FromLong (event->crossing.y);
                        if (!strcmp (attr, "related"))
                                return pygobject_new ((GObject *) event->crossing.related);
                        break;
		default:
			break;
	}

        /* common attributes, see ClutterAnyEvent */

	if (!strcmp (attr, "type"))
		return pyg_enum_from_gtype (CLUTTER_TYPE_EVENT_TYPE, event->type);

	if (!strcmp (attr, "time"))
                return PyInt_FromLong (clutter_event_get_time (event));

        if (!strcmp (attr, "flags"))
                return pyg_flags_from_gtype (CLUTTER_TYPE_EVENT_FLAGS, event->any.flags);

        if (!strcmp (attr, "modifier_state"))
                return pyg_flags_from_gtype (CLUTTER_TYPE_MODIFIER_TYPE,
                                             clutter_event_get_state (event));

        if (!strcmp (attr, "source"))
                return pygobject_new ((GObject *) clutter_event_get_source (event));

        if (!strcmp (attr, "stage"))
                return pygobject_new ((GObject *) clutter_event_get_stage (event));

	return Py_FindMethod ((PyMethodDef *) _PyClutterEvent_methods, self, attr);
}
%%
