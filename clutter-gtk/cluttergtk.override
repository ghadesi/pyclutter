%%
headers
#define NO_IMPORT_PYGOBJECT
#include "pygobject.h"
#include <clutter/clutter.h>
#include <clutter-gtk/clutter-gtk.h>
%%
modulename cluttergtk
%%
import gobject.GObject as PyGObject_Type
import clutter.Actor as PyClutterActor_Type
import clutter.Texture as PyClutterTexture_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import gtk.Widget as PyGtkWidget_Type
import gtk.Adjustment as PyGtkAdjustment_Type
import gtk.Container as PyGtkContainer_Type
%%
ignore
  gtk_clutter_scrollable_get_adjustments noargs
%%
ignore-glob
  *_get_type
%%
body

static PyObject *
_wrap_gtk_clutter_texture_set_from_pixbuf (PyGObject *self,
                                           PyObject  *args,
                                           PyObject  *kwargs)
{
  static char *kwlist[] = { "pixbuf", NULL };
  PyGObject *py_pixbuf = NULL;
  GError *error = NULL;

  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!:cluttergtk.Texture.set_from_pixbuf", kwlist, &PyGdkPixbuf_Type, &py_pixbuf))
    return NULL;

  gtk_clutter_texture_set_from_pixbuf (CLUTTER_TEXTURE (self->obj),
                                       GDK_PIXBUF (py_pixbuf->obj),
                                       &error);
  if (pyg_error_check(&error))
    return NULL;

  Py_INCREF (Py_None);
  return Py_None;
}

static PyObject *
_wrap_gtk_clutter_texture_set_from_stock (PyGObject *self,
                                          PyObject  *args,
                                          PyObject  *kwargs)
{
  static char *kwlist[] = { "widget", "stock_id", "icon_size", NULL };
  PyGObject *py_widget = NULL;
  char *stock_id = NULL;
  GtkIconSize icon_size = -1;
  GError *error = NULL;

  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!s|i:cluttergtk.Texture.set_from_stock", kwlist, &PyGtkWidget_Type, &py_widget, &stock_id, &icon_size))
    return NULL;

  gtk_clutter_texture_set_from_stock (CLUTTER_TEXTURE (self->obj),
                                      GTK_WIDGET (py_widget->obj),
                                      stock_id,
                                      icon_size,
                                      &error);
  if (pyg_error_check(&error))
    return NULL;

  Py_INCREF (Py_None);
  return Py_None;
}

static PyObject *
_wrap_gtk_clutter_texture_set_from_icon_name (PyGObject *self,
                                              PyObject  *args,
                                              PyObject  *kwargs)
{
  static char *kwlist[] = { "widget", "icon_name", "icon_size", NULL };
  PyObject *py_widget = NULL;
  char *icon_name = NULL;
  GtkIconSize icon_size = -1;
  GError *error = NULL;

  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "Os|i:cluttergtk.Texture.set_from_icon_name", kwlist, &py_widget, &icon_name, &icon_size))
    return NULL;

  if (py_widget == NULL || py_widget == Py_None)
    gtk_clutter_texture_set_from_icon_name (CLUTTER_TEXTURE (self->obj),
                                            NULL,
                                            icon_name,
                                            icon_size,
                                            &error);
  else if (pygobject_check (py_widget, &PyGtkWidget_Type))
    {
      GtkWidget *widget = GTK_WIDGET (pygobject_get (py_widget));

      gtk_clutter_texture_set_from_icon_name (CLUTTER_TEXTURE (self->obj),
                                              widget,
                                              icon_name,
                                              icon_size,
                                              &error);
    }
  else
    {
      PyErr_SetString (PyExc_TypeError, "widget must be a gtk.Widget or None");
      return NULL;
    }

  if (pyg_error_check(&error))
    return NULL;

  Py_INCREF (Py_None);
  return Py_None;
}

static int
_wrap_gtk_clutter_texture_new (PyGObject *self, PyObject *args, PyObject *kwargs)
{
  pygobject_constructv (self, 0, NULL);
  if (!self->obj)
    {
      PyErr_SetString (PyExc_RuntimeError, "could not create cluttergtk.Texture object");
      return -1;
    }

  return 0;
}

static PyMethodDef _PyClutterGtkTexture_methods[] = {
  { "set_from_pixbuf", (PyCFunction) _wrap_gtk_clutter_texture_set_from_pixbuf, METH_VARARGS | METH_KEYWORDS },
  { "set_from_stock", (PyCFunction) _wrap_gtk_clutter_texture_set_from_stock, METH_VARARGS | METH_KEYWORDS },
  { "set_from_icon_name", (PyCFunction) _wrap_gtk_clutter_texture_set_from_icon_name, METH_VARARGS | METH_KEYWORDS },
  { NULL, NULL, 0 }
};

PyTypeObject PyClutterGtkTexture_Type = {
    PyObject_HEAD_INIT (NULL)
    0,
    "cluttergtk.Texture",
    sizeof(PyGObject),
    0,
    /* methods */
    (destructor)0,                      /* tp_dealloc */
    (printfunc)0,                       /* tp_print */
    (getattrfunc)0,                     /* tp_getattr */
    (setattrfunc)0,                     /* tp_setattr */
    (cmpfunc)0,                         /* tp_compare */
    (reprfunc)0,                        /* tp_repr */
    0,                                  /* tp_as_number */
    0,                                  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    (hashfunc)0,                        /* tp_hash */
    (ternaryfunc)0,                     /* tp_call */
    (reprfunc)0,                        /* tp_str */
    (getattrofunc)0,                    /* tp_getattro */
    (setattrofunc)0,                    /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,                 /* tp_flags */
    "A clutter.Texture enhanced with some additional cluttergtk methods", /* Documentation string */
    (traverseproc)0,                    /* tp_traverse */
    (inquiry)0,                         /* tp_clear */
    (richcmpfunc)0,                     /* tp_richcompare */
    offsetof(PyGObject, weakreflist),   /* tp_weaklistoffset */
    (getiterfunc)0,                     /* tp_iter */
    (iternextfunc)0,                    /* tp_iternext */
    _PyClutterGtkTexture_methods,       /* tp_methods */
    0,                                  /* tp_members */
    0,                                  /* tp_getset */
    (PyTypeObject *)0,                  /* tp_base */
    (PyObject *)0,                      /* tp_dict */
    0,                                  /* tp_descr_get */
    0,                                  /* tp_descr_set */
    offsetof(PyGObject, inst_dict),     /* tp_dictoffset */
    (initproc)_wrap_gtk_clutter_texture_new, /* tp_init */
    0,                                  /* tp_alloc */
    0,                                  /* tp_new */
    0,                                  /* tp_free */
    (inquiry)0,                         /* tp_is_gc */
    (PyObject *)0,                      /* tp_bases */
};
%%
init
  PyClutterGtkTexture_Type.tp_base = &PyClutterTexture_Type;
  if (PyType_Ready (&PyClutterGtkTexture_Type) < 0) {
    g_return_if_reached ();
  }
  if (PyDict_SetItemString (d, "Texture", (PyObject *) &PyClutterGtkTexture_Type) < 0) {
    g_return_if_reached ();
  }
%%
override gtk_clutter_get_fg_color kwargs
static PyObject *
_wrap_gtk_clutter_get_fg_color (PyObject *object,
                                PyObject *args,
                                PyObject *kwargs)
{
  static char *kwlist[] = { "widget", "state", NULL };
  PyGObject *py_widget = NULL;
  GtkStateType state = 0;
  ClutterColor color = { 0, };

  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!i:get_fg_color", kwlist, &PyGtkWidget_Type, &py_widget, &state))
    return NULL;

  gtk_clutter_get_fg_color (GTK_WIDGET (py_widget->obj), state, &color);

  return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override gtk_clutter_get_bg_color kwargs
static PyObject *
_wrap_gtk_clutter_get_bg_color (PyObject *object,
                                PyObject *args,
                                PyObject *kwargs)
{
  static char *kwlist[] = { "widget", "state", NULL };
  PyGObject *py_widget = NULL;
  GtkStateType state = 0;
  ClutterColor color = { 0, };

  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!i:get_bg_color", kwlist, &PyGtkWidget_Type, &py_widget, &state))
    return NULL;

  gtk_clutter_get_bg_color (GTK_WIDGET (py_widget->obj), state, &color);

  return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override gtk_clutter_get_text_color kwargs
static PyObject *
_wrap_gtk_clutter_get_text_color (PyObject *object,
                                  PyObject *args,
                                  PyObject *kwargs)
{
  static char *kwlist[] = { "widget", "state", NULL };
  PyGObject *py_widget = NULL;
  GtkStateType state = 0;
  ClutterColor color = { 0, };

  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!i:get_text_color", kwlist, &PyGtkWidget_Type, &py_widget, &state))
    return NULL;

  gtk_clutter_get_text_color (GTK_WIDGET (py_widget->obj), state, &color);

  return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override gtk_clutter_get_base_color kwargs
static PyObject *
_wrap_gtk_clutter_get_base_color (PyObject *object,
                                  PyObject *args,
                                  PyObject *kwargs)
{
  static char *kwlist[] = { "widget", "state", NULL };
  PyGObject *py_widget = NULL;
  GtkStateType state = 0;
  ClutterColor color = { 0, };

  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "O!i:get_base_color", kwlist, &PyGtkWidget_Type, &py_widget, &state))
    return NULL;

  gtk_clutter_get_base_color (GTK_WIDGET (py_widget->obj), state, &color);

  return pyg_boxed_new (CLUTTER_TYPE_COLOR, &color, TRUE, TRUE);
}
%%
override gtk_clutter_viewport_get_origin noargs
static PyObject *
_wrap_gtk_clutter_viewport_get_origin (PyGObject *object)
{
    gfloat x, y, z;

    gtk_clutter_viewport_get_origin (GTK_CLUTTER_VIEWPORT (object->obj),
                                    &x, &y, &z);
    return Py_BuildValue ("(fff)", x, y, z);
}

